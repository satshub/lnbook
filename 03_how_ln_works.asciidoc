[[ch03_How_Lightning_Works]]
== 闪电网络如何工作

((("Lightning Network (generally)","mechanism of operation", id="ix_03_how_ln_works-asciidoc0", range="startofrange")))现在我们已经跟随 Alice 设置了一个闪电钱包并从 Bob 那里购买了一杯咖啡，我们将深入了解并解开该过程中涉及的闪电网络的不同组件。
本章将提供高级概述，不会深入研究所有技术细节，目标是帮助您了解闪电网络最重要的概念和构建模块。


如果你有计算机科学、密码学、比特币和协议开发方面的经验，那么这一章应该足以让你自行展开相应的技术细节。
如果您经验不足，本章将为您提供足够好的概述，以便您更轻松地理解正式的协议规范，称为 BOLT（闪电技术基础）。如果你是初学者，本章将帮助你更好地理解本书的技术章节。


如果您需要复习比特币的基础知识，您可以在 <<bitcoin_fundamentals_review>> 中找到对以下主题的总结回顾：

* 密钥和地址
* 哈希函数
* 数字签名
* 交易结构
* 交易输入和输出
* 交易链
* 比特币脚本
* 多重签名地址和脚本
* 时间锁
* 复杂的脚本


我们将从一句话定义闪电网络是什么开始，并在本章的其余部分对其进行分解。


闪电网络是关于 _支付通道_ 的点对点网络，它在 _比特币网络_ 上以智能合约的形式体现，并定义相关通信协议来确定参与者如何设置和执行这些智能合约。

[[what_is_payment_channel]]
===  什么是支付通道？


((("Lightning Network (generally)","payment channel defined")))((("payment channel","defined")))有几种方法可以描述支付渠道，具体取决于上下文。 让我们从高层次开始，然后添加更多细节。


支付渠道是闪电网络上两个节点之间的 _财务关系_，称为 _渠道合作伙伴_。 财务关系在两个渠道合作伙伴之间分配了一个“资金余额”（以毫聪计）。


((("cryptographic protocol")))支付通道由 _加密协议_ 管理，这意味着通道合作伙伴使用基于加密的预定义流程来重新分配通道的余额，以支持一个或另一个通道合作伙伴。加密协议确保一个通道合作伙伴不能欺骗对方，因此合作伙伴之间，不需要相互信任。


加密协议是通过一个2/2型 _多签地址_ 的质押资金建立的。该地址要求两个通道合作伙伴进行合作，并防止任一通道合作伙伴单方面花费质押资金。


总结一下：支付通道是节点之间的财务关系，通过严格定义的加密协议从多重签名地址分配资金。

=== Payment Channel Basics
=== 支付通道基础


((("Lightning Network (generally)","payment channel basics")))((("payment channel","basics")))支付渠道的基础是比特币区块链上的一个2/2型 多重签名地址，您持有一个密钥，而您的渠道合作伙伴持有另一个密钥。


您和您的通道伙伴，共同协商基于该多重签名地址如何进行一系列的交易。 这不是在比特币区块链上传输和记录这些交易，而是你们都持有这些交易，只是没有最终结算。


该交易序列中的最新交易，将对通道余额进行编码，并定义余额在您和您的渠道伙伴之间的分配方式。


因此，向该交易序列添加新交易相当于将部分通道余额从一个通道伙伴转移到另一个通道伙伴，而比特币网络对此是无感知的。 当您协商每笔新交易、更改通道中的资金分配时，您也同步地撤销了之前的交易，这样任何一方都不能回到之前的状态。

序列中的每笔交易都使用比特币的脚本语言来达成，因此您和您的通道伙伴之间的资金分配协商，是由比特币智能合约管理。
设置智能合约是为了惩罚通道成员，如果他们试图提交之前撤销的通道状态。


[NOTE]
====
如果您有来自 2-of-2 多重签名地址的未发布交易，该交易向您支付了部分余额，那么来自另一方的签名，可确保您可以随时通过添加自己的签名，来独立发布此交易。

持有部分签署的交易（离线和未发布）的能力，以及持有随时发布和拥有该余额的能力，是闪电网络的基础。
====

=== 通过通道进行路由支付


((("Lightning Network (generally)","routing payments across channels")))((("payment channel","routing payments across channels")))一旦多个参与者拥有从一方到另一方的通道，网络中将具有多个不同的支付通道。此时，付款也可以通过设置连接多个支付通道的路径，从一个支付通道“转发”到另一个支付通道。


例如，如果 Alice 与 Bob 有一个通道并且 Bob 与 Charlie 有一个通道，则 Alice 可以向 Charlie 汇款。


基于闪电网络的设计，可以扩展运行通道的智能合约，同时使 Bob 无法窃取通过他的通道转发的资金。


就像智能合约保护通道伙伴不需要相互信任一样，整个网络也保护参与者。这样他们就可以在不信任任何其他参与者的情况下转发付款。


因为通道是由多重签名地址构建的，余额更新交易是预签名的比特币交易，所以运行闪电网络所需的所有信任，都来自对去中心化比特币网络的信任！


上述创新无疑是允许创建闪电网络的重大突破。但是，闪电网络不仅仅是比特币脚本语言之上的加密协议。它是一种全面的通信协议，允许对等方交换闪电消息以实现比特币的转移。通信协议定义了闪电消息如何加密和交换。


闪电网络还使用八卦协议将有关通道（网络拓扑）的公开信息分发给所有参与者。


例如，Alice 需要网络拓扑信息来了解 Bob 和 Charlie 之间的通道，以便她可以构建到 Charlie 的路由。


最后但同样重要的是，要明白闪电网络只不过是比特币之上的一个应用程序，它使用比特币交易和比特币脚本进行构建。 没有“闪电币”或“闪电区块链”。
除了所有技术原语之外，LN 协议是一种创造性的方式，可以通过即时结算允许任意数量的即时支付，而无需信任比特币网络以外的任何其他人，从而从比特币中获得更多收益。

=== 支付通道


正如我们在前一章中看到的，Alice 使用她的钱包软件，在她自己和另一个 LN 参与者之间创建了一个支付通道。


((("payment channel","limitations on")))一个通道只受三个方面的限制：


* 首先是基于几百字节的互联网传输协议，将资金从通道的一端转移到另一端所需的时间

* 其次是通道容量，即通道开通时承诺的比特币数量

* 第三，比特币交易的最大大小限制还限制了可以通过一个通道同时进行的不完整（正在进行的）路由支付的数量


((("payment channel","useful properties")))同时，支付通道也有一些非常有趣和有用的属性：


* 由于更新渠道的时间主要受互联网通信速度的限制，因此在支付渠道上进行支付几乎是瞬时的。


* 如果通道是开放的，支付不需要比特币区块的确认。事实上闪电网络只要你和你的渠道伙伴遵守协议，它不需要与比特币网络或除了你的通道伙伴以外的任何其他人进行任何交互。

[role="pagebreak-before"]
* 加密协议的构建，使得您和您的通道合作伙伴之间几乎不需要任何信任。 如果您的通道伙伴长时间没有响应或试图欺骗您，您可以要求比特币系统充当“法庭”，解决您和您的通道伙伴之前达成的智能合约。


* 只有您和您的通道伙伴知道在支付通道中所进行的支付交易。从这个意义上说，与每笔交易都是公开的比特币相比，你获得了隐私。只有最终余额，即该通道中所有付款的总和，才会在比特币网络上可见。


当比特币诞生大约5年后，才华横溢的开发人员第一次想出了如何构建双向、无限期、可路由的支付渠道。现在至少有三种不同的已知方法。

本章将重点介绍 Joseph Poon 和 Thaddeus Dryja 于 2015 年在 https://lightning.network/lightning-network-paper.pdf[Lightning Network whitepaper] 中首次描述的通道构建方法。((("Poon-Dryja channels")))这些被称为_Poon-Dryja_通道，是闪电网络中目前使用的通道构建方法。
其他两种提议的方法是：

- _Duplex Micropayment_ 通道，由 Christian Decker提出， 与 Poon-Dryja 通道几乎在同一时间提出；

- _eltoo_ 通道，在 https://blockstream.com/eltoo.pdf["eltoo: A Simple Layer2 Protocol for for 比特币”]论文中， 由 Christian Decker、Rusty Russel 和（本书的合著者）Olaoluwa Osuntokun 于 2018 年提出。


eltoo 通道有一些有趣的特性，可以简化支付渠道的实现。 但是，eltoo 通道需要更改比特币脚本语言，因此自 2020 年起无法在比特币主网上实施。

==== 多签地址

((("multisignature addresses")))((("payment channel","multisignature addresses")))Payment channels are built on top of 2-of-2 multisignature addresses.
((("multisignature addresses")))((("payment channel","multisignature addresses")))支付渠道建立在 2-of-2 多重签名地址之上。



总之，多重签名地址是比特币被锁定的地方，因此需要多个签名才能解锁和花费。 在闪电网络中使用的 2/2 多重签名地址中，有两个参与的签名者并且同时签名才能花费资金。


多重签名脚本和地址在<<multisig>>.

[role="pagebreak-before less_space"]
==== 质押交易


((("funding transaction")))((("payment channel","funding transaction")))支付通道的基本构建模块是 2/2多重签名地址。两个渠道合作伙伴之一将通过向多重签名地址发送比特币,来为支付通道提供资金。 该交易称为质押交易，并记录在比特币区块链上。


尽管质押交易是公开的，但除非该通道被公开宣传，否则在关闭之前，我们看不出来这是一个闪电支付通道。 通道通常由希望转发付款的路由节点公开宣布。然而，非公开型通道也存在，并且通常由不主动参与路由的移动节点创建。 此外，除了通道合作伙伴之外，任何人都看不到通道支付，也看不到他们之间的通道余额分配。


((("channel capacity")))存入多重签名地址的金额称为_通道容量_，并设置可以通过支付通道发送的最大金额。但是，由于资金可以来回发送，通道容量并不是可以通过通道转移多少资金量的上限。这是因为如果通道容量因一个方向的支付而耗尽，它可以用于再次向相反方向发送支付。


[NOTE]
====
在质押交易中，发送到多重签名地址的资金有时被称为“闪电通道锁定资金”。 然而，在实践中，闪电通道中的资金不是“锁定”而是“释放”。 闪电通道资金比比特币网络上的资金更具流动性，因为它们可以更快、更便宜、更私密地使用。 将资金转移到闪电网络有一些缺点（例如需要将它们保存在“热”钱包中），但在闪电网络中“锁定资金”的想法具有误导性。
====

===== 小额通道示例


((("payment channel","example of poor channel opening procedure")))如果您深入思考 2/2多重签名地址，您会意识到将资金存入这样的地址似乎存在一定风险。 如果您的渠道合作伙伴拒绝签署交易以释放资金怎么办？他们永远被困住了吗？ 现在让我们看看这种情况以及LN协议如何避免这种情况。


Alice 和 Bob 想要创建一个支付通道。他们各自创建一个私钥/公钥对，然后交换公钥。 现在，他们可以使用两个公钥构建一个 2-of-2 的多重签名，为他们的支付通道奠定基础。


接下来，Alice 构建一个比特币交易，将几个 mBTC 发送到由 Alice 和 Bob 的公钥创建的多重签名地址。 如果 Alice 不采取任何额外步骤而只是广播该交易，她必须相信 Bob 会提供他的签名以从多重签名地址中支出。 另一方面，Bob有机会通过扣留Alice的签名并拒绝Alice访问她的资金,从而来敲诈Alice。


为了防止这种情况发生，Alice 需要创建一个从多重签名地址花费的额外交易，将她的 mBTC 退还给她。 然后 Alice 让 Bob 在将她的资金交易广播到比特币网络之前签署退款交易。 这样，即使 Bob 消失或不合作，Alice 也可以获得退款。


保护 Alice 的“退款”交易是称为 _commitment transactions_ 的一类交易中的第一个，我们将在接下来更详细地研究它。

==== 承诺交易

((("commitment transactions")))((("payment channel","commitment transaction")))_承诺交易_ 是向每个通道伙伴支付其通道余额，同时确保渠道伙伴不必相互信任的交易。 通过签署承诺交易，每个通道伙伴对当前余额做出“承诺”，并让其他通道伙伴能够随时取回他们的资金。


通过签署承诺交易，每个通道伙伴即使没有其他通道伙伴的合作也可以获得他们的资金。 这可以保护他们免受其他通道伙伴的失踪、拒绝合作或试图通过违反支付通道协议进行欺骗。


Alice在前面的例子中发起的承诺交易，是将她的初始付款退还给多重签名地址。 然而，更一般地说，承诺交易会拆分支付通道的资金，根据他们各自持有的余额，支付给两个通道合作伙伴。 起初，Alice 持有所有余额，因此是简单的退款。但是当资金从Alice流向Bob时，他们会为代表新余额分配的新承诺交易交换签名，其中一部分资金支付给 Alice，另一部分支付给 Bob。


假设 Alice 与 Bob 打开一个容量为 100,000 satoshi 的支付通道。
最初，Alice 拥有 100,000 satoshi，即通道中的全部资金。 以下是支付通道协议的工作原理：

. Alice 创建一个新的私钥/公钥对，并通知 Bob 她希望通过“open_channel”消息（LN 协议中的消息）打开一个通道。
. Bob 还创建了一个新的私钥/公钥对，并同意接受来自 Alice 的通道，通过“accept_channel”消息将他的公钥发送给 Alice。
. Alice 现在从她的钱包创建一个质押交易，将 100k satoshi 发送到带有锁定脚本的多重签名地址：+2 <PubKey Alice> <PubKey Bob> 2 CHECKMULTISIG+。
. Alice 还没有广播这个质押交易，而是在“funding_created”消息中向 Bob 发送交易 ID 以及她对 Bob 的承诺交易的签名。
. Alice 和 Bob 都创建了他们的承诺交易版本。该交易将从质押交易中支出，并将所有比特币发送回 Alice 控制的地址。
. Alice 和 Bob 不需要交换这些承诺交易，因为他们每个人都知道它们是如何构建的，并且可以独立构建两者（因为他们已经就输入和输出的规范排序达成一致）。他们只需要交换签名。
. Bob 为 Alice 的承诺交易提供签名，并通过“funding_signed”消息将其发送回 Alice。
. 现在签名已经交换，Alice 将把质押交易广播到比特币网络。


通过遵循此协议，即使资金被发送到 Alice 仅控制一个密钥的 2-of-2 多重签名地址，Alice 也不会放弃她的 100k satoshi 的所有权。
如果 Bob 停止回复 Alice，她将能够广播她的承诺交易并收回她的资金。
她唯一的成本是链上交易的费用。
只要她遵守协议，这是她打开通道时唯一的风险。


在此初始交换之后，每次通道余额发生变化时都会创建承诺交易。换句话说，每次在 Alice 和 Bob 之间发送付款时，都会创建新的承诺交易并交换签名。每个新的承诺交易都会编码 Alice 和 Bob 之间的最新余额。


如果 Alice 想向 Bob 发送 30k satoshi，两者都将创建一个新版本的承诺交易，现在将向 Alice 支付 70k satoshi，向 Bob 支付 30k satoshi。通过为Alice和Bob编码新的余额，新的承诺交易是通过渠道“发送”付款的方式。


现在我们了解了承诺交易，让我们看看一些更微妙的细节。您可能会注意到，此协议为Alice或Bob留下了作弊的途径。

==== 利用前置状态行骗


((("cheating","with prior state", id="ix_03_how_ln_works-asciidoc1", range="startofrange")))((("payment channel","cheating with prior state", id="ix_03_how_ln_works-asciidoc2", range="startofrange")))在上面的例子中，Alice 向 Bob 支付 30k satoshi 后持有多少承诺交易？她持有两个：最初的一个支付给她 100k satoshi，而最近的一个支付给她70k satoshi 和 Bob 30k satoshi。


在我们目前看到的通道协议中，没有什么能阻止 Alice 发布之前的承诺交易。 作弊的Alice可以发布授予她 10 万聪的承诺交易。
由于该承诺交易是由 Bob 签署的，他无法阻止 Alice 提交该承诺到比特币网络。


需要一些机制来防止 Alice 发布旧的承诺交易。 现在让我们看看如何实现这一点，以及它如何使闪电网络能够在不需要 Alice 和 Bob 之间的任何信任的情况下运行。


因为比特币是抗审查的，所以没有人可以阻止某人发布旧的承诺交易。为了防止这种形式的作弊，如果有人构建了承诺交易，并且广播了旧的承诺交易，则可以惩罚作弊者。 通过使惩罚足够大，我们对作弊产生了强烈的激励，这使得系统安全。


惩罚的方式是让被骗方有机会索取作弊者的余额。因此，如果有人试图通过广播旧的承诺交易来作弊，在该交易中，他们得到的余额高于应得的余额，另一方可以通过拿走自己的余额和作弊者的余额来惩罚他们。 骗子失去了一切！


[TIP]
====
您可能会注意到，如果 Alice 几乎完全耗尽了她的通道余额，那么她可以尝试作弊而风险很小。 如果 Bob 的通道余额很低，那么她的惩罚就不会那么痛苦。 为了防止这种情况，闪电协议要求每个通道合作伙伴在通道中保持最低限度的余额（称为 _reserve_），以便他们始终可以做到利益捆绑。
====

让我们再过一遍通道构建的场景，在这个过程中增加一个惩罚机制来防止作弊：

. Alice 与 Bob 创建了一个通道，并将 100k satoshi 放入其中。
. Alice 发送 30k satoshi 给 Bob。
. Alice 试图通过发布一个旧的承诺交易来欺骗 Bob，从他赚取的 30k satoshi 中获取自己的全部 100k satoshi。
. Bob 检测到欺诈行为并通过为自己拿走全部 100k satoshi 来惩罚 Alice。
. Bob 最终获得 100k satoshi，因发现 Alice 作弊而获得 70k satoshi。
. Alice 以 0 satoshi 结束。
. 试图从 30k satoshi 中欺骗 Bob，她失去了她拥有的 70k satoshi。


有了强大的惩罚机制，Alice 不会因为发布旧的承诺交易而作弊，因为她有失去全部余额的风险。



[NOTE]
====
在 _Mastering Bitcoin_ 的第 12 章中，Andreas Antonopoulos（本书的合著者）陈述如下：
“比特币的一个关键特征是，一旦交易有效，它就会保持有效并且不会过期。取消交易的唯一方法是在被挖矿成功之前，将其UTXO与另一笔交易进行双重支付。”
====


现在我们了解为什么需要惩罚机制以及它如何防止作弊，让我们看看它是如何详细工作的。


通常，承诺交易至少有两个输出，支付给每个渠道伙伴。((("revocation secret")))((("timelock delay")))我们将其更改为向其中一项付款添加 _timelock delay_ 和 _revocation secret_。 一旦承诺交易被包含在一个块中，时间锁会阻止输出的所有者立即花费它。 撤销秘密允许任何一方立即花费这笔款项，绕过时间锁。


因此，在我们的示例中，Bob 持有一笔承诺交易，该交易立即支付给Alice，但他自己的付款被延迟且可撤销。 Alice 也持有承诺交易，但她的则相反：它立即支付给 Bob，但她自己的付款被延迟且可撤销。


两个通道伙伴，每人持有一半的撤销秘密，因此谁都不知道全部秘密。 如果他们分享他们的一半，那么另一个通道合作伙伴就拥有完整的秘密，可以使用它来行使撤销条件。 在签署新的承诺交易时，每个通道合作伙伴通过将其一半的撤销秘密提供给对方来撤销先前的承诺。


我们将在 <<revocation>> 中更详细地研究撤销机制，在那里我们将了解如何构建和使用撤销秘密的细节。


简单来说，只有当 Bob 为先前的承诺提供他的一半撤销秘密时，Alice 才会签署 Bob 的新承诺交易。 Bob只有在Alice向他提供前一个承诺的撤销秘密的一半时，才签署Alice的新承诺交易。


对于每个新的承诺，他们交换必要的“惩罚”秘密，使他们能够通过让清算无利可图，来有效地撤销先前的承诺交易。从本质上讲，它们破坏了在签署新承诺时使用旧承诺的能力。我们的意思是，虽然在技术上仍然可以使用旧的承诺，但惩罚机制使得这样做在经济上是不合理的。


时间锁可设置的最大值是2,016 个区块高度（大约两周）。 如果任一通道伙伴在未与其他合作伙伴合作的情况下发布承诺交易，他们将不得不等待该数量的区块（例如，两周）才能领取余额。而其他通道合作伙伴可以随时提取自己的余额。 此外，如果他们发布的承诺是已被撤销的旧承诺，通道伙伴也可以立即提取作弊方的余额，绕过时间锁定并惩罚作弊者。


时间锁是可调的，可以在通道合作伙伴之间协商。 通常，较大容量的通道，时间较长；较小的通道，时间较短。以使激励措施与资金价值保持一致。


对于通道余额的每次更新，都必须创建和保存新的承诺交易和新的撤销秘密。只要通道保持打开状态，就需要保留该通道的所有 _曾经创建_的撤销秘密，因为将来可能需要用到它们。幸运的是，这些秘密很小，只有渠道合作伙伴需要保留它们，而不是全网中的每个节点都要保留。此外，基于生成撤销机密的智能派生机制，我们只需要存储最近的机密，因为可以从中派生以前的机密（请参阅<<revocation_secret_derivation>>）。


然而，管理和存储撤销机密是闪电节点中需要节点操作员维护备份的更复杂的部分之一。


[NOTE]
====
瞭望塔服务或将通道构建协议更改为 eltoo 协议等技术，可能是未来缓解这些问题并减少对撤销秘密、惩罚交易和通道备份的需求的策略。
====


如果 Bob 没有响应，Alice 可以随时关闭通道，并要求公平地拿到余额。
在链上发布 _last_ 承诺交易后，Alice 必须等待时间锁到期，然后她才能从承诺交易中花费她的资金。 正如我们稍后将看到的，有一种更简单的方法来关闭通道而无需等待，只要 Alice 和 Bob 都在线，并合作以正确的余额分配关闭通道。但是，每个通道合作伙伴存储的承诺交易，起到了故障保险的作用，确保当通道合作伙伴出现问题时，不会让自己的资金受损。

==== 公布通道


((("payment channel","announcing the channel")))((("public channel, announcing")))通道合作伙伴可以同意向整个闪电网络宣布他们的通道，使其成为一个_公共通道_。 为了宣布通道，他们使用闪电网络的八卦协议，告诉其他节点该通道的存在以及容量和费用。


公开宣布通道，允许其他节点使用该通道进行路由支付，从而也为通道合作伙伴赚取路由费用。


((("unannounced channels")))相比之下，频道合作伙伴也可能决定不公布通道，使其成为 _未公布_ 频道。



[NOTE]
====
您可能会听到用于描述未公开通道的术语为“私人频道”。我们避免使用该术语，因为它具有误导性并会产生虚假的隐私感。虽然未公开的通道在使用时不会被其他人知道，但当通道关闭时，它的存在和容量将被揭示，因为这些细节将在最终结算交易中在链上可见。它的存在还可能以其他多种方式泄露，因此我们避免称其为“私有”。
====


未公开通道仍可以用于路由支付，但仅由知道其存在的节点使用，或给出一些路由提示，该提示包含未公布通道的路径。


当使用 gossip 协议公开宣布通道及其容量时，公告还可以包括有关通道（元数据）的其它信息，例如其路由费用和时间锁持续时间。


当新节点加入闪电网络时，它们会从相邻节点，通过八卦协议收集公开的通道信息，构建闪电网络的内部地图。然后可以使用此地图查找支付路径，将通道端到端的连接在一起。

==== 关闭通道

((("closing the channel", id="ix_03_how_ln_works-asciidoc3", range="startofrange")))((("payment channel","closing the channel", id="ix_03_how_ln_works-asciidoc4", range="startofrange")))关闭通道的最佳方法是......不要关闭它！
打开和关闭通道需要进行链上交易，这会产生交易费用。因此，最好尽可能长时间地保持通道开放。只要您的通道末端有足够的容量，您就可以继续使用您的通道进行付款和转帐。但是，即使您将所有余额发送到通道的另一端，您也可以使用该通道，从您的通道合作伙伴处接收付款。这种在一个方向使用通道，然后在相反方向使用它的概念称为“重新平衡”，我们将在另一章中更详细地研究它。通过重新平衡渠道，它可以几乎无限期地保持开放，基本上可以无限数量的进行支付。


但是，有时关闭通道是可取的或必要的。 例如：

* 出于安全原因，您想减少闪电通道上的余额，并希望将资金发送到“冷钱包”。
* 您的通道合作伙伴长时间无响应，您无法再使用该通道。
* 由于您的通道合作伙伴不是连接良好的节点，因此该通道不经常使用，因此您希望将资金用于另一个连接更好的节点的通道。
* 您的通道合作伙伴由于软件错误或故意违反协议，迫使您关闭渠道以保护您的资金。

有三种方式来关闭一个支付通道:

* 相互关闭（好方法）
* 强制关闭（坏方法）
* 协议犯规（丑陋的方式）


这些方法中的每一种都适用于不同的情况，我们将在本章的下一节中进行探讨。例如，如果您的通道合作伙伴离线，您将无法遵循“好方法”，因为没有合作伙伴就无法完成相互关闭。通常，您的LN软件会根据情况自动选择可用的最佳关闭策略。

===== 相互关闭（好方法）


((("closing the channel","mutual close")))((("mutual close")))相互关闭发生在当两个渠道合作伙伴同意关闭一个通道时，是通道关闭的首选方法。


当您决定要关闭某个通道时，您的LN节点会把您的意图，通知到您的通道合作伙伴。现在您的节点和通道合作伙伴的节点决定共同关闭通道。至此，任何一个通道合作伙伴都不会接受任何新的路由尝试，并且任何正在进行的路由尝试将在超时后被结算或删除。完成路由尝试需要时间，因此相互关闭也可能需要一些时间才能完成。

((("closing transactions")))一旦没有挂起的路由尝试，节点就会相互合作发起 _关闭交易_。
该交易类似于承诺交易：它对通道的最后余额进行编码，但输出不受时间锁的阻碍。

关闭交易的链上交易费用由打开通道的渠道合作伙伴支付，而不是由启动关闭程序的一方支付。
使用链上费用估算器，通道合作伙伴同意适当的费用并签署关闭交易。


一旦 关闭交易 被比特币网络广播并确认，通道就被有效关闭了。每个通道合作伙伴都收到了他们在通道余额中的份额。尽管有等待时间，但相互关闭通常比强制关闭更快。

===== 强制关闭（坏方法）


((("closing the channel","force close")))((("force close")))强制关闭是指一个通道合作伙伴，在未经其他通道合作伙伴同意的情况下，尝试关闭一个通道。


这通常发生在其中一个通道合作伙伴无法访问，导致不能采用优雅的“相互关闭”方式。在这种情况下，您将启动强制关闭，单方面关闭通道并“释放”资金。


要启动强制关闭，您可以简单地发布您的节点拥有的最后一个承诺交易。
毕竟，这就是承诺交易的用途——它们提供了一种保证，即您无需信任您的通道合作伙伴即可取回您的渠道余额。

((("commitment transactions","during force close")))一旦您将最后一个承诺交易广播到比特币网络并得到确认，它将创建两个可花费的输出，一个给您，另一个给您的合作伙伴。
正如我们之前所讨论的，比特币网络无法知道这是最近的承诺交易，还是为从您的合作伙伴那里窃取而发布的旧交易。
因此，此承诺交易将为您的合作伙伴带来一点优势。即发起强制关闭的合作伙伴的输出将受到时间锁的阻碍，而另一个合作伙伴的输出将立即可用。
如果您广播了较早的承诺交易，则时间锁定延迟使您的合作伙伴有机会使用撤销秘密对交易提出异议并惩罚您的作弊行为。


在强制关闭期间发布承诺交易时，链上费用将高于相互关闭，原因如下：


. 在协商承诺交易时，通道合作伙伴不知道未来交易广播时的链上费用是多少。由于在不更改承诺交易的输出（需要两个签名）的情况下无法更改费用，并且由于通道合作伙伴无法签名时会发生强制关闭，因此协议开发人员决定非常慷慨地在承诺交易中提高交易费。它可能比协商承诺交易时所建议的费用估算者高出五倍。


. 承诺交易包括任何挂起的路由尝试哈希时间锁定合约（HTLC）的额外输出，这使得承诺交易（以字节计）大于相互关闭交易。较大的交易会产生更多的费用。


. 任何挂起的路由支付，都必须在链上解决，从而导致额外的链上交易。


[NOTE]
====
哈希时间锁合约 (HTLC) 将在 <<htlcs>> 中详细介绍。
目前，假设这些支付是通过闪电网络路由进行的，而不是直接在两个通道合作伙伴之间进行的。
这些 HTLC 在承诺交易中作为附加输出携带，从而增加交易规模和链上费用。
====


一般来说，除非绝对必要，否则不建议强制关闭。
您的资金将被锁定更长的时间，打开通道的人将不得不支付更高的费用。
此外，即使您没有打开通道，您也可能需要支付链上费用来中止或解决路由尝试。


如果您知道通道合作伙伴，您可以考虑联系该个人或公司，询问他们的闪电节点为什么关闭了？并要求他们重新启动它，以便您可以实现通道的相互关闭。


您应该仅将强制关闭视为最后的手段。

===== 协议犯规（丑陋的方式）


((("closing the channel","protocol breach")))((("protocol breach")))协议违规是指您的渠道合作伙伴试图通过向比特币区块链发布过时的承诺交易来欺骗您，无论对方故意与否，实质上都是从他们那一侧发起的欺诈行为。


您的节点必须在线并观察比特币区块链上的新区块和交易，以检测对方是否犯规，故意欺诈。


因为您的渠道合作伙伴的付款，将受到时间锁的限制，您的节点有一些时间来检测协议违规，并让您在时间锁到期之前提交 (((“punishment transaction”))) _惩罚交易_。


如果您成功检测到协议违规并执行处罚，您将收到渠道中的所有资金，包括您的渠道合作伙伴的资金。

在这种情况下，通道关闭通常会非常快。您必须支付链上费用才能发布惩罚交易，但您的节点可以根据费用估算，来设置这些费用，而不是多付。您可能会希望支付更高的费用以保证尽快确认。但是，由于您最终将收到作弊者的所有资金，因此可以认为是作弊者在为此交易支付费用。

如果您未能检测到协议违规并且时间锁到期，您将仅收到您的合作伙伴在发布的承诺交易中分配给您的资金。
您在此之后收到的任何资金都将被您的通道伙伴偷走。
如果后续有任何余额分配给您，您将必须支付链上费用才能收取该余额。

与强制关闭一样，所有排队的路由支付也必须在提交的交易中被解决。


协议违反可以比相互关闭更快执行，因为您无需等待与您的合作伙伴协商关闭；也比强制关闭更快，因为您无需等待时间锁到期。


从博弈论可以看出，作弊不是一种吸引人的策略。因为作弊者很容易被发现，作弊者在冒着失去所有资金的风险的情况下，只能获得他们在早期状态下的资金。
此外，随着闪电网络的成熟和瞭望塔的广泛使用，即使被骗的通道合作伙伴离线，第三方也可以检测到作弊者。

因此，作弊是不可取的。同时，我们建议任何抓到作弊者的人，通过拿走作弊者的资金来惩罚他们。

那么，您如何在日常活动中发现作弊或违反协议的行为？
你可以通过运行软件来监控公共比特币区块链上的链上交易，这些交易对应于你的任何渠道的任何承诺交易。
该软件有以下三种类型：


* 一个适当维护的闪电节点，24x7 运行
* 一个单一用途的瞭望塔节点，您可以运行它来监控您的支付通道
* 给第三方瞭望塔节点付费，让他们帮您监控通道

请记住，承诺交易是有超时时间的，最多为 2,016 个区块高度。
只要您在达到超时期限之前运行一次闪电节点，它就会捕获所有作弊行为，但我们不建议这么做。毕竟，维护一个运行良好且稳定的节点很重要（参见<<continuous_operation>>）。

=== 发票


((("Lightning invoices", id="ix_03_how_ln_works-asciidoc5", range="startofrange")))闪电网络上的大多数付款都是从收款人创建的发票开始的。 在我们之前的示例中，Bob 创建了一张请求 Alice 付款的发票。


[NOTE]
====
有一种方法可以在没有发票的情况下发送未经请求的付款，这种方法在协议中称为 +keysend+ 。 我们将在 <<keysend>> 中对此做进一步的研究。
====


所谓发票，是一个简单的支付指令集，其中包含唯一支付标识符（称为支付哈希）、收件人、金额和可选文本描述等信息。


发票中最重要的部分是支付哈希，它允许付款以“原子”方式跨多个通道传递。原子性，在计算机科学中，是指任何成功完成或根本没有完成的动作或状态变化，没有中间状态或部分动作的可能性。在闪电网络中，这意味着支付要么走完整个路径，要么完全失败。它不能部分完成，因此路径上的中间节点可以接收付款并保留它。记住，没有“部分付款”或“部分成功付款”之类的东西。


发票不通过闪电网络来回传递。相反，它们是使用一种称为“带外通信”的模式进行通信的。 这有点类似于比特币地址如何与比特币网络之外的比特币发送者通信，例如二维码、电子邮件或短信。 例如，Bob 可以通过电子邮件或任何其他消息渠道，将闪电发票以 QR 码的形式呈现给 Alice。


发票通常表现为bech32编码长字符串或二维码，然后经由智能手机闪电钱包扫描。发票包含请求的比特币数量和收件人的签名。发送方使用签名来提取接收方的公钥（也称为节点 ID），以便发送方知道将付款发送到哪里。


((("Bitcoin–Lightning Network comparisons","addresses versus invoices")))您是否注意到这与比特币有何不同以及如何使用不同的术语？在比特币中，收款人将地址发送给付款人。 在闪电网络中，收款人创建发票并将发票发送给付款人。在比特币中，付款人将资金发送到一个地址。在闪电网络中，付款人支付发票，然后将付款发送给收款人。比特币基于“地址”的概念，闪电网络是基于“发票”概念的支付网络。在比特币中，我们创建一个“交易”，而在闪电网络中，我们发送一个“付款”。

==== 付款哈希及原像


((("Lightning invoices","payment hash/preimage")))发票最重要的部分是付款哈希。 在构造发票时，Bob 将按如下方式进行付款哈希构造：


1. ((("payment secret (preimage)")))((("preimage (payment secret)")))Bob 选择一个随机数 _r_。 这个随机数称为 _原像_ 或 _付款秘密_。
2. Bob 使用 SHA-256 计算 _r_ 的哈希值 _H_，称为 _付款哈希_： pass:[<br/>]_H_ = SHA-256(_r_)。



[NOTE]
====
_原像_ 一词来自数学。 在任何函数 _y = f_(_x_) 中，产生特定值 _y_ 的输入集合称为 _y_ 的原像。 在上述情况下，函数是 SHA-256 哈希算法，任何产生哈希 _H_ 的值 _r_ 都称为原像。
====


截止目前，没有任何方法可以找到 SHA-256 散列值的原像。 只有 Bob 知道 _r_ 的值，所以它是 Bob 的秘密。 但是一旦 Bob 揭示了 _r_，任何拥有哈希 _H_ 的人都可以通过计算 SHA-256(_r_) 并查看它是否匹配 _H_ 来检查 _r_ 是否是正确的秘密。


只有当 _r_ 完全随机选择且不可预测时，闪电网络的支付过程才是安全的。这种安全性依赖于这样一个事实，即哈希函数是不可逆的或被暴力破解掉，因此没有人可以从 _H_ 中找到 _r_。

==== 附加信息


((("Lightning invoices","additional metadata")))((("metadata, Lightning invoices and")))发票可以选择包含其他有用的元数据，例如简短的文本描述等。如果用户有几张发票要支付，用户可以阅读描述并了解发票的内容。


((("routing hints")))发票还可以包含一些_路由提示_，允许付款人使用未公开的通道来构建到收款人的路由。 路由提示还可用于提议一些公共通道，例如，接收方已知的某些通道，这些通道具有足够的资金容量来进行支付路由。


如果付款人的闪电节点，无法通过闪电网络发送付款，发票可以选择包含一个链上的比特币地址作为后备。

[NOTE]
====
虽然总是有可能将比特币交易“退回”到链上，但实际上最好为收款者打开一个新渠道。 如果您必须支付链上费用才能进行支付，您不妨支付这些费用来打开通道并通过闪电网络进行支付。 付款后，您将获得一个开放通道，该通道在收款人端具有流动性，可用于将来将付款路由回您的闪电节点。 一次链上交易，将为您提供付款和未来使用的闪电支付渠道。
====


闪电发票包含到期日期。由于收款人必须为每张开具的发票保留原像 _r_，所以让发票过期很有用，这样这些原像就不需要永远保留。 一旦发票到期或已付款，收款人可以丢弃原像。(((range="endofrange", startref="ix_03_how_ln_works-asciidoc5")))

=== 支付传递

((("Lightning Network (generally)","delivering payment", id="ix_03_how_ln_works-asciidoc6", range="startofrange")))((("payment","delivering", id="ix_03_how_ln_works-asciidoc7", range="startofrange")))((("payment delivery", seealso="pathfinding", id="ix_03_how_ln_works-asciidoc8", range="startofrange")))我们已经看到收款人如何创建包含付款哈希的发票。 这个支付哈希将用于在一系列支付通道中移动的支付。即使从付款人到收款者之间没有直接的支付通道。


在接下来的几节中，我们将深入探讨用于通过闪电网络进行支付的想法和方法，并使用我们迄今为止提出的所有概念。


首先，让我们看一下闪电网络的通信协议。


==== 点对点Gossip协议


((("gossip protocol","peer-to-peer", id="ix_03_how_ln_works-asciidoc9", range="startofrange")))((("payment delivery","peer-to-peer gossip protocol", id="ix_03_how_ln_works-asciidoc10", range="startofrange")))((("peer-to-peer gossip protocol", id="ix_03_how_ln_works-asciidoc11", range="startofrange")))正如我们之前提到的，在构建支付通道时，通道合作伙伴可以选择将其公开，向整个闪电网络公布其存在和详细信息。


通道公告是通过点对点 _gossip 协议_ 完成的。 对等协议是一种通信协议，其中每个节点，通过TCP/IP协议，随机选择网络中的其他节点，建立链接。 每个直连到您的节点的节点都称为您的 _peers_。 反过来，您的节点是他们的对等节点之一。 请记住，当我们说您的节点连接到其他对等点时，我们并不是说你们之间有支付渠道，而只是说您通过 gossip 协议进行连接。


((("channel_announcement message","peer-to-peer gossip protocol and")))打开通道后，节点可以选择通过“channel_announcement”消息向其对等方发送通道公告。
每个对等点都验证来自“channel_announcement”消息的信息，并验证资金交易在比特币区块链上得到确认。
经过验证后，节点会将八卦消息转发给自己的对等方，由他们转发给自己的对等方，以此类推，将公告传播到整个网络。为了避免过度通信，只有在之前没有转发过该公告的每个节点，才转发该信道公告。


((("node_announcement message","peer-to-peer gossip protocol and")))gossip 协议还用于通过“node_announcement”消息宣布有关已知节点的信息。
要转发此消息，转发节点至少有一个已经通过gossip 协议宣布的公共通道，以避免过多的通信流量。



支付通道具有对网络的其他参与者有用的各种元数据，这些元数据主要用于做出路由决策。
((("channel_update message")))由于节点可能偶尔会更改其频道的元数据，因此，此信息在 `channel_update` 消息中共享。这些消息在每个支付通道内每天仅转发大约四次，以防止过度通信。gossip 协议也有各种查询和消息，用于初始同步节点与网络视图或在离线一段时间后更新节点视图。

闪电网络参与者面临的一个主要挑战是八卦协议共享的拓扑信息只是部分的。
例如，支付通道的容量通过 [.keep-together]#`channel_announcement`# 消息在 gossip 协议上共享。
但是，就两个通道合作伙伴之间的本地余额而言，此信息不如实际的容量分配有用。
一个节点只能在该通道内转发它实际拥有的比特币（本地余额）。


尽管闪电网络本可以设计为共享通道的余额信息和精确的网络拓扑，但由于以下几个原因尚未这样做：




* 为了保护用户的隐私，它不会对外广播每笔金融交易和支付。因为，渠道余额更新将揭示付款已跨通道转移，通过这些，可以关联这些信息然后揭示所有支付来源和目的地。 这破坏了用户隐私。

* 为了扩展闪电网络可以进行的支付金额。闪电网络最初在创建的时候，由于通知每个参与者每笔付款导致它不能很好地扩展。因此，闪电网络不能以在参与者之间共享通道余额更新的方式设计。

* 闪电网络是一个动态系统。它不断且频繁地变化。例如:正在添加节点，正在关闭其他节点，正在更改余额等。即使始终传达所有信息，信息也只会在很短的时间内有效。事实上，信息在收到时往往已经过时。


我们将在后面的章节中研究 gossip 协议的细节。

目前，只需要知道 gossip 协议的存在以及它用于共享闪电网络的拓扑信息即可。
此拓扑信息对于通过支付渠道网络进行支付至关重要。(((range="endofrange", startref="ix_03_how_ln_works-asciidoc11")))(((range="endofrange", startref="ix_03_how_ln_works-asciidoc10")))(((range="endofrange", startref="ix_03_how_ln_works-asciidoc9")))

==== 路径寻找和路由


((("pathfinding")))((("payment delivery","pathfinding and routing")))((("routing","payment delivery and"))) 闪电网络上的支付是沿着由连接一个参与者到另一个参与者的通道组成的 _path_ 转发的，从支付源到支付目的地。 寻找从源到目的地的路径的过程称为 _pathfinding_。 使用该路径进行支付的过程称为 _routing_。


[NOTE]
====
对闪电网络的一个常见批评是路由没有解决，甚至是一个“无法解决”的问题。 事实上，路由是微不足道的。 从另一方面来讲，寻路是一个难题。这两个术语经常混淆，我们需要明确区分二者的定义，以确定我们即将解决的问题。
====


正如我们接下来将看到的，闪电网络目前使用 _source-based_ 协议进行寻路，使用 _onion-routed_ 协议进行支付。 基于付款人 意味着付款的发送者必须在闪电网络中，找到抵达收款人的路径。 洋葱路由意味着路径的元素是分层的（像洋葱一样），每一层都加密，因此一次只能被一个路由节点看到。 我们将在下一节讨论洋葱路由。

=== 基于付款人的路径寻找


((("pathfinding","source-based", id="ix_03_how_ln_works-asciidoc12", range="startofrange")))((("payment delivery","source-based pathfinding", id="ix_03_how_ln_works-asciidoc13", range="startofrange")))((("source-based pathfinding", id="ix_03_how_ln_works-asciidoc14", range="startofrange")))如果我们知道每个通道的确切通道余额，我们可以使用任何计算机科学课程中教授的任何标准寻路算法轻松计算支付路径。 这甚至可以通过优化支付给节点以转发付款的费用的方式来解决。



但是，所有通道的余额信息没法也不可能被网络的所有参与者所知。我们需要更多创新的寻路策略。


在网络拓扑只披露部分信息的情况下，寻路是一个真正的挑战。当然，对闪电网络寻路的研究，仍在持续进行。 闪电网络中的寻路问题并未“完全解决”，这也是人们对闪电网络的主要批评点。


[NOTE]
====
对闪电网络中寻路的一个常见批评是它没有被彻底解决。因为它等同于 NP-complete (((“traveling salesperson problem”))) _旅行销售员问题_ (TSP)，这是计算复杂性理论中的一个基本问题。 事实上，闪电网络中的寻路并不等同于 TSP，而是属于另一类问题。 就像我们每次要求 Google 为我们提供避免交通拥堵的行车路线时，我们都成功地解决了这个类型的问题（在信息不完整的图中的寻路）。 每次我们在闪电网络上进行支付时，我们也成功地解决了这个问题。
====


寻路和路由可以通过多种不同的方式实现，多种寻路和路由算法可以在闪电网络上共存，就像互联网上存在多种寻路和路由算法一样。 基于源的寻路是许多可能的解决方案之一，并且在闪电网络的当前规模下是完全可行的。


目前闪电节点实施的寻路策略是迭代尝试路径，直到找到一个有足够流动性来转发支付的路径。 这是一个反复试验的过程，直到成功或找不到路径。该算法目前不一定会找到费用最低的路径。 虽然这不是最优的路径，但即使是这种简单化的策略也能很好地工作。当然，我们可以继续改进寻路策略。



这种“探测”由闪电节点或钱包完成，不会对用户直接展示这个探测过程。如果付款没有立即完成，用户可能只会意识到正在进行路径探测。


[NOTE]
====
在互联网上，我们使用网络协议和路由算法将网络包从发件人转发到目的地。虽然这些协议，具有允许互联网主机相互协作找到通过互联网的信息流路径的良好特性，但我们不能在闪电网络上重用这些协议，进行支付转发。因为，与互联网不同，闪电支付必须是原子的，渠道余额必须保持隐私。 此外，闪电网络中的通道容量变化频繁，这与连接容量相对静态的互联网不同。闪电网络的这些特性，需要我们探索新的寻路策略。
====



当然，如果我们想向我们的直接通道合作伙伴付款，并且我们在通道方面有足够的余额来这样做，那么寻路就会变的微不足道。 当然，在其他情况下，我们的节点会使用来自gossip协议的信息来进行支付寻路。这些信息包括：当前已知的公共支付通道、已知节点、已知拓扑（已知节点如何连接）、已知通道容量和节点所有者设置的已知费用策略等。

==== 洋葱路由


((("onion routing protocol")))((("pathfinding","onion routing protocol")))((("payment delivery","onion routing protocol")))闪电网络使用类似于著名的 Tor（洋葱路由器）网络的 _onion 路由协议_。

((("SPHINX Mix Format", seealso="onion routing")))闪电网络中使用的洋葱路由协议称为 _SPHINX Mix Format_，footnote:[George Danezis 和 Ian Goldberg，“Sphinx: A Compact and Provably Secure Mix Format”，在 _IEEE Symposium on Security and Privacy_（纽约：IEEE，2009） , 269–282.] 这将在后面的章节中详细解释。


[NOTE]
====
Lightning 的洋葱路由 SPHINX Mix Format 仅在概念上类似于 Tor 网络路由，但无论是协议规定还是实现都与 Tor 网络中使用的完全不同。
====


用于路由的支付包称为“洋葱”。footnote:[The term "onion" was originally used by the Tor project. Moreover, the Tor network is also called the Onion network and the project uses an onion as its logo. The top-level domain name used by Tor services on the internet is _onion_.]


让我们使用洋葱类比来跟踪路由支付。在从付款发送方（付款人）到付款目的地（收款人）的路径上，洋葱沿着路径从一个节点传递到另一个节点。 发送者从里向外，逐层构建整个洋葱消息。 首先，发送者为付款的（最终）接收者创建付款信息，并使用只有接收者才能解密的加密方式，对其进行加密。 然后，发送者将该层与路径中的节点的指令包裹在_紧接在最终接收者之前_的路径中，并使用只有该节点才能解密的加密方式，进行加密。


这些层是用指令逐层构建的，直到整个路径被编码在层中。然后，发送者将完整的洋葱交给路径中的第一个节点，该节点只能读取最外层。 每个节点剥一层，在里面找到指示路径中的下一个节点，然后传递洋葱。由于每个节点剥去一层，它就无法读取洋葱的其余部分。它只知道洋葱刚刚从哪里来以及接下来要去哪里，而没有任何迹象表明谁是最初的发送者或最终接收者。


这种情况一直持续到洋葱到达付款目的地（即收款人）。 然后，目的节点打开洋葱，发现没有更多的层可以解密，可以读取里面的支付信息。


[NOTE]
====
与真正的洋葱不同，在剥离每一层时，当前节点会添加一些加密填充，以保证洋葱消息在每一跳之间的消息大小都是相同的。 正如我们将看到的，这使得任何中间节点都不可能知道路径的大小（长度）、路由中涉及的节点数量、它们之前的节点数量或后面的节点数量。这样做是为了防止琐碎的流量分析攻击，以增强隐私。
====


闪电网络中使用的洋葱路由协议具有以下属性：



* 中间节点只能看到它在哪个通道上收到了一个洋葱消息，以及将在哪个通道上转发这个洋葱消息。这意味着没有路由节点可以知道谁发起了付款以及付款的目的地。这是最重要的属性，导致高度隐私。


* 洋葱消息足够小，可以放入单个TCP/IP数据包甚至是链路（例如以太网）帧中。这使得支付的流量分析变得更加困难，进一步增加了隐私。


* 洋葱消息的构造使其始终具有相同的消息长度，而与中间路由节点的位置无关。由于每一层都被“剥皮”，然后被加密的“垃圾”数据填充，从而保证了洋葱消息的大小相同。 这可以防止中间节点感知它们在支付路径中的位置。


洋葱在每一层都有一个 HMAC（基于哈希的消息验证码）。因此可以防止对洋葱内容的人为操纵，实际上操纵是不可能的。


* 如果您愿意，洋葱消息最多可以有26跳，或者称为洋葱层。这个路径长度，足够用了。可用的精确路径长度取决于在每一跳分配给路由有效负载的字节数。


* 每一跳的洋葱消息，其加密使用的是不同的临时加密密钥。如果密钥（特别是节点的私钥）在某个时间点泄漏，攻击者也不会解密完整的洋葱消息。简而言之，通过在不同节点之间，使用不同的密钥以实现更高的安全性。


* 错误可以使用相同的洋葱路由协议，从出错的节点发送回原始发送者。错误洋葱与将洋葱路由到外部观察者和中间节点没有区别。错误路由启用试错“探测”方法，用于查找具有足够容量以成功路由付款的路径。


洋葱路由将在 <<onion_routing>> 中进一步详述。

==== 支付转发算法


((("payment delivery","payment forwarding algorithm")))一旦付款的发送者在网络中找到一条可能的路径并构建一个洋葱消息，付款将由路径中的每个节点依次转发。每个节点处理一层洋葱并将其转发到路径中的下一个节点。


((("update_add_htlc message")))每个中间节点都会收到一条名为“update_add_htlc”的闪电消息，其中包含支付哈希和洋葱。 中间节点执行的一系列步骤，称为 _支付转发算法_：


. 节点解密洋葱消息的最外层并检查消息的完整性。


. 节点根据通道费用和转出通道的可用容量，确认它可以满足路由支付。


. 节点与转入通道资金的通道合作伙伴一起更新通道状态。


. 节点在洋葱消息的末尾添加了一些填充字节以使其长度保持不变，因为它在刚收到洋葱消息时，删除了一些数据。

. 节点遵循路由提示，通过发送包含相同支付哈希和洋葱的“update_add_htlc”消息，在其支付通道上转发修改后的洋葱包。


. 节点与转出通道资金的通道合作伙伴一起更新通道状态。


当然，如果检测到错误，这些步骤将被中断并中止，并将错误消息发送回 `update_add_htlc` 消息的发起者。 错误消息也被格式化为洋葱并在转入通道上向前回传。


随着错误消息在路径上的每个通道上逐级向前回传，通道合作伙伴删除待处理的付款，以与开始时相反的方式回滚付款。


如果整个网络的支付失败的可能性很高，如果它不能迅速解决，节点不应该在洋葱返回错误之前沿着不同的路径发起另一次支付尝试。 如果两次付款尝试最终都成功，发件人将支付两次。

=== 点对点通信加密


((("Lightning Network (generally)","peer-to-peer communication encryption")))((("peer-to-peer communication encryption")))LN 协议主要是其参与者之间的点对点协议。正如我们在前几节中看到的，网络中有两个重叠的功能，形成了两个逻辑网络，它们一起构成了 _闪电网络_ ：


1. 一个广泛的点对点网络，使用八卦协议传播拓扑信息，其中对等节点随机连接。节点之间不一定有支付渠道，因此他们并不总是通道合作伙伴。


2. 通道伙伴之间的支付通道网络。 通道伙伴使用八卦协议同步网络拓扑，这意味着他们是八卦协议中的对等节点。


对等点之间的所有通信都是通过称为 _Lightning messages_ 的消息发送的。 这些消息都被加密，使用称为 _Noise Protocol Framework_ 的加密通信框架((("Noise Protocol Framework","Lightning messages and")))。 噪声协议框架允许构建提供身份验证、加密、前向保密和身份隐私的加密通信协议。 噪声协议框架还用于许多流行的端到端加密通信系统，例如 WhatsApp、WireGuard 和 I2P。更多信息可以在 https://noiseprotocol.org[在噪声协议框架网站] 上找到。


在闪电网络中使用噪声协议框架，可确保网络上的每条消息都经过身份验证和加密，从而增加了网络的隐私性及其对流量分析、深度数据包检查和窃听的抵抗力。然而不太好的是，这使得协议开发和测试有点棘手，因为人们不能简单地使用数据包捕获或网络分析工具（如 Wireshark）来观察网络。 相反，开发者必须使用专门的插件从节点的角度来解密协议，例如 Wireshark 插件 https://github.com/nayutaco/lightning-dissector[_lightning dissector_]。

=== 关于信任的思考

((("Lightning Network (generally)","trust and")))((("trust, Lightning Network and")))只要一个人遵循协议并确保其节点安全，参与闪电网络时就没有重大的资金损失风险。
但是，开通通道需要支付链上费用。
任何成本都应该带来相应的收益。
在我们的案例中，Alice 承担开通通道的成本的奖励是，Alice可以发送并在将一些硬币移动到通道的另一端后，随时在闪电网络上接收比特币付款，并且她可以通过为其他人转发付款来赚取比特币费用。
Alice 知道，理论上 Bob 可以在打开通道后立即关闭通道，从而为 Alice 产生链上关闭费用。
Alice 需要对 Bob 有一点信任。
Alice 去过 Bob 的咖啡馆，显然 Bob 有兴趣卖掉她的咖啡，所以 Alice 在这个意义上可以信任 Bob。
Alice和Bob都有共同的利益。
Alice 认为奖励足以让她承担为 Bob 创建通道的链上费用。
相比之下，Alice不会向刚刚不请自来的陌生人，因为向她发送一封电子邮件要求她打开一个新通道，他就去开的。

=== 与比特币的比较


((("Bitcoin–Lightning Network comparisons", id="ix_03_how_ln_works-asciidoc15", range="startofrange")))虽然闪电网络建立在比特币之上并继承了它的许多特性和属性，但两个网络的用户都需要注意一些重要的区别。

((("Bitcoin–Lightning Network comparisons", id="ix_03_how_ln_works-asciidoc15", range="startofrange")))


其中一些差异是术语上的差异。另外，用户体验和系统架构也存在差异。在接下来的几节中，我们将深究这些差异和相似之处，解释这些术语并调整我们对这些差异的理解。

==== 地址 vs 支票， 交易 vs 支付

((("Bitcoin–Lightning Network comparisons","addresses versus invoices")))((("Bitcoin–Lightning Network comparisons","transactions versus payments")))在使用比特币的典型支付场景中，用户会收到一个比特币地址（例如，扫描网页上的二维码，或者从朋友的即时消息或电子邮件中接收）。 然后他们使用自己的比特币钱包创建交易，并将资金发送到该地址。


在闪电网络上，收款人会创建一张发票。闪电发票可以看作类似于比特币地址。预期收款人将闪电发票作为二维码或字符串提供给付款人，就像比特币地址一样。


付款人使用他们的闪电钱包通过复制发票文本或扫描发票二维码来支付发票。一笔闪电支付类似于比特币中的“交易”。


同时，在用户体验上，也存在一些差异。比特币地址是可重用的。比特币地址永不过期，如果地址的所有者仍然持有密钥，则其中的资金始终可以访问。发件人可以将任意数量的比特币发送到以前使用的地址，收件人可以发布一个静态地址来接收许多付款。 虽然从隐私的角度看，这违背了最佳实践，但它在技术上是可行的，实际上很常见。


然而，在闪电网络中，每张发票只能一次性的用于特定的付款金额。您不能多付或少付，不能再次使用发票，并且发票内置了到期时间。在闪电网络中，收件人必须为每次付款生成新发票，并提前指定付款金额。对此有一个例外，称为 _keysend_ 的机制，我们将在 <<keysend>> 中对其进行研究。

==== 选择交易输出 vs 寻找支付路径


((("Bitcoin–Lightning Network comparisons","selecting outputs versus finding a path")))((("unspent transaction outputs (UTXOs)")))((("UTXOs (unspent transaction outputs)")))为了在比特币网络上进行支付，发送者需要消耗一个或多个未使用的交易输出（UTXO）。
如果用户有多个 UTXO，他们（或者更确切地说是他们的钱包）将需要选择要发送的 UTXO。
例如，支付 1 BTC 的用户可以使用价值 1 BTC 的单个输出，价值 0.25 BTC 和 0.75 BTC 的两个输出，或每个价值 0.25 BTC 的四个输出。


在闪电网络上，进行支付不需要消耗输入。不同的是，每次付款都会更新通道余额，在两个通道合作伙伴之间重新分配余额。 付款人将此描述为将通道余额从他们的一端“移动”到另一端(即他们的通道合作伙伴)。 闪电支付使用从付款人到收款人的一系列路由通道完成支付。 这些通道中的每一个通道，都必须有足够的容量来完成路由付款。


因为可以使用许多可能的通道和路径进行支付，所以闪电网络用户对通道和路径的选择有点类似于比特币用户对 UTXO 的选择。


借助原子多路径支付 (AMP) 和多部分支付 (MPP) 等技术，可以将多个闪电路径聚合成单个原子支付，就像可以将多个比特币 UTXO 聚合成单个原子的比特币进行交易一样。我们将在后续章节中回顾这些技术。

==== 比特币改变输出 vs 闪电网络没有变化


((("Bitcoin–Lightning Network comparisons","change outputs")))为了在比特币网络上进行支付，发送者需要消耗一个或多个未使用的交易输出（UTXO）。 UTXO 只能全额使用； 它们不能被分割和部分花费。 因此，如果用户希望花费 0.8 BTC，但只有 1 BTC UTXO，他们需要通过将 0.8 BTC 发送给接收者并将 0.2 BTC 作为找零发回自己来花费整个 1 BTC UTXO。 0.2 BTC 找零支付创建了一个新的 UTXO，称为“找零输出”。


在闪电网络上，质押交易会花费一些比特币 UTXO，以此创建一个多重签名 UTXO 来打开通道。 一旦比特币被锁定在该通道内，它的一部分就可以在通道内来回发送，而无需创建任何更改。
这是因为通道合作伙伴只是简单地更新通道余额，并且仅在通道最终使用通道关闭交易关闭时创建一个新的 UTXO。

==== 矿工费 vs 路由费 
((("Bitcoin–Lightning Network comparisons","mining fees versus routing fees")))在比特币网络上，用户向矿工支付费用，以便将他们的交易打包到一个区块中。这些费用支付给开采该特定区块的矿工。费用金额取决于交易在区块中使用的交易大小（以 _bytes_ 为单位），以及用户希望以多快的速度开采该交易。因为矿工通常会首先挖掘最有利可图的交易，所以希望立即挖掘其交易的用户将为每字节支付 _更高_ 的费用，而不着急的用户将为每字节支付较低的费用。


在闪电网络上，用户向中间路由节点支付费用，以便可以借助他们的通道完成支付。为了进行支付，中间节点必须在他们拥有的两个或多个通道中转移资金，并为转账人的支付信息传输数据。 通常，路由用户将根据付款的 _value_ ，基于已确定最低 ((("base fee"))) _base fee_（每次付款的固定费用）和 ((("fee rate" )))_fee rate_（与付款价值成比例的按比例分配的费用），向付款人收取费用。因此，更高价值的支付将花费更多的路由成本。基于此，将形成了一个流动性市场，不同的用户通过他们的渠道收取不同的路由费用。

==== 基于交易量的Fee vs 路由节点自定价的Fee


((("Bitcoin–Lightning Network comparisons","varying fees versus announced fees")))在比特币网络上，矿工追求利润，通常会在一个区块中包含尽可能多的交易，同时将总的交易字节量维持在称为 ((("block weight")))_block weight_ 的区块容量内。


((("transaction weight")))如果队列中的交易（称为 _mempool_）超过了一个块的容量，矿工将首先挖掘每单位（字节）_transaction weight_ 支付最高费用的交易。
因此，当队列中有很多交易时，用户必须支付更高的费用才能进入下一个区块，或者他们必须等待队列中的交易较少。
这自然会导致收费市场的出现，用户根据他们需要将交易包含在下一个区块中的紧急程度来支付费用。


比特币网络上的稀缺资源是区块中的空间。比特币用户争夺区块空间，比特币费用市场以可用区块空间为基础。闪电网络中的稀缺资源是  ((("channel connectivity")))((("channel liquidity")))  _通道流动性_ （可用于通道中路由的资金容量）和 _通道连接性_ （有多少连接良好节点通道可以到达）。闪电用户争夺通道容量和连接性； 因此，闪电网络费用市场是由容量和连接性驱动的。


在闪电网络上，付款人向路由中继节点支付费用。从经济角度来看，路由支付只不过是为付款人提供和分配通道容量。 自然，在消耗相同通道容量的情况下，收取较低费用的路由节点，将更具竞争力。 因此，存在一个收费市场，在这个市场中，就路由节点而言，他们会因为通过其通道进行支付所收取的费用，而相互竞争。

==== 比特币公开交易 vs 闪电网络隐私支付


((("Bitcoin–Lightning Network comparisons","public Bitcoin transactions versus private Lightning payments")))在比特币网络上，每笔交易都在比特币区块链上公开可见。 虽然所涉及的地址是匿名的，并且地址通常不与身份相关联，但网络上的每个其他用户仍然可以看到和验证它们。
此外，区块链监控公司会大量收集和分析这些数据，并将其出售给私营公司、政府和情报机构等相关方。


另一方面，LN 支付几乎是完全私密的。 通常，只有付款人和收款人完全了解特定支付的来源、目的地和交易金额。 此外，收款人甚至可能不知道付款人的来源。因为支付是洋葱路由的，所以路由支付的用户只知道支付的金额，他们既不能确定付款人也不能确定收款人。


总之，比特币交易是公开广播并永久存储的。闪电支付在几个选定的节点之间执行，有关它们的信息在通道关闭之前，仅被节点私下存储。在闪电网络上创建与比特币相同的大规模监控和分析工具，将变的非常困难。

==== 等待确认与即时结算


((("Bitcoin–Lightning Network comparisons","waiting for confirmations versus instant settlement")))在比特币网络上，交易只有在被包含在一个区块中后才会被结算，在这种情况下，它们被称为在该区块中被“确认”。 随着更多的区块被开采，交易获得更多的“确认”并且被认为更安全。


在闪电网络上，交易确认仅对打开和关闭链上通道很重要。一旦资金交易达到合适的确认次数（例如 3 次），通道合作伙伴就会认为该通道成功开通。 由于通道中的比特币受到管理该通道的智能合约的保护，因此一旦最终收款人收到付款，就会 _立即_ 结算。
实际上，即时结算意味着付款只需几秒钟即可执行和结算。与比特币一样，闪电支付是不可逆的。


最后，当通道关闭时，需要在比特币网络上发起一笔结算交易； 一旦该交易被确认，该通道被视为关闭。

==== 发送任意金额与容量限制


((("Bitcoin–Lightning Network comparisons","sending arbitrary amounts versus capacity restrictions"))) 在比特币网络上，用户可以将他们拥有的任意数量的比特币发送给另一个用户，而不受容量限制。 理论上，单笔交易最多可以发送 2100 万比特币作为付款。



在闪电网络上，用户只能将当前存在于特定通道一侧的比特币发送给通道合作伙伴。 例如，如果用户拥有一个通道，其一侧有 0.4 BTC，另一个通道一侧有 0.2 BTC，那么他们一次付款最多可以发送 0.4 BTC。无论用户当前在其比特币钱包中拥有多少比特币，这都是事实。


((("multipart payments (MPP)")))多部分支付 (MPP) 是一项功能，在前面的示例中，它允许用户将他们的 0.4 BTC 和 0.2 BTC 通道结合起来，一次支付最多发送 0.6 BTC。 MPP 目前正在闪电网络中进行测试，预计到本书完成时将广泛使用和使用。 有关 MPP 的更多详细信息，请参阅 <<mpp>>。


如果支付被路由，则路由路径上的每个路由节点必须具有容量至少与被路由的支付金额相同的通道。 这必须适用于支付通过的每个单一渠道。 路径中容量最低的通道的容量设定了整个路径的容量上限。


因此，容量和连接性是闪电网络中至关重要且稀缺的资源。

==== 鼓励大额支付 vs 鼓励小额支付


((("Bitcoin–Lightning Network comparisons","fee structures")))((("fees","Bitcoin–Lightning Network comparisons")))在比特币网络中，其费用结构与交易价值无关。假设交易大小相似，一笔 100 万美元的交易与一笔 1 美元的比特币交易的费用相同，以字节为单位（更具体地说，是 SegWit [隔离见证协议] 之后的“虚拟”字节）。
在闪电网络中，费用是固定基础费用加上交易价值的百分比。因此，在闪电网络中，支付费用随着支付价值的增加而增加。
这些对立的费用结构会产生不同的激励措施，并导致在交易价值方面的不同使用。价值更高的交易在比特币上会更便宜；因此，用户会更喜欢比特币进行大额交易。同样，在规模的另一端，用户会更喜欢闪电网络进行小额交易。

==== 区块链是账本 vs 区块链是仲裁


((("Bitcoin–Lightning Network comparisons","blockchain: ledger versus court system")))在比特币网络上，每笔交易最终都会记录在区块链上的一个区块中。因此，区块链形成了自比特币创建以来每笔交易的完整历史，并提供了一种对存在的每一个比特币进行全面审计的方法。一旦交易被包含在区块链中，它就是终局的。
因此，不会出现任何争议。并且在区块链中的特定点，由特定地址控制多少比特币都是明确的。

在闪电网络上，特定时间通道中的余额只有两个通道合作伙伴知道，并且只有在通道关闭时才对整个网络可见。
当通道关闭时，通道的最终余额将提交给比特币网络，每个合作伙伴都会收到他们在该通道中的比特币余额。
例如，如果 Alice 用 1 BTC 创建了一个到Bob的通道，随后 Alice 向 Bob 支付了 0.3 BTC，那么通道的最终余额是 Alice 的 0.7 BTC 和 Bob 的 0.3 BTC。
如果 Alice 试图通过向比特币区块链提交通道的初始状态来作弊，希望自己获得 1 BTC，Bob 获得 0 BTC；那么 Bob 可以通过提交通道的真实最终状态以及创建惩罚交易来进行惩罚Alice，这会将通道中的所有比特币都转给他。
对于闪电网络，比特币区块链充当法院系统。就像机器人法官一样，比特币记录每个通道的初始和最终余额，并在其中一方试图作弊时执行处罚。

==== 在线 vs 离线, 同步 vs 异步

((("Bitcoin–Lightning Network comparisons","minimum payment size: satoshi versus millisatoshi")))((("Bitcoin–Lightning Network comparisons","payment activity: asynchronous versus synchronous")))((("millisatoshi")))((("satoshi")))当比特币用户将资金发送到收款人地址时，他们不需要知道任何有关收款人的信息。收件人可能离线或在线，并且不需要发件人和收件人之间的交互。交互发生在付款人和比特币区块链之间。在比特币区块链上接收比特币是一种_被动_和_异步_活动，不需要收款人进行任何交互或收款人随时在线。 比特币地址甚至可以离线生成，并且永远不会在比特币网络中“注册”。只有花费比特币才需要交互。


在闪电网络中，收款人必须在线才能在付款到期前完成付款。收款人必须运行一个节点或让某人代表他们运行一个节点（第三方托管人）。准确地说，付款人和收款人的两个节点在付款时都必须在线并且必须进行交互。 接收闪电支付是发送方和接收方之间的 _主动_ 且 _同步_ 活动，这种活动需要极少数的闪电网络或比特币网络参与。


和比特币网络相比，闪电网络的同步和始终在线的特性可能是用户体验的最大差异，这常常让习惯比特币的用户感到困惑。

==== 聪和毫聪


在比特币网络上，最小的数量是一个_satoshi_，不能再进一步分割。 闪电网络更加灵活，闪电网络节点使用 _millisatoshis_（千分之一聪）。 这允许通过闪电网络发送小额付款。 单个毫秒支付可以通过支付渠道发送，金额如此之小，应该恰当地描述为 _纳米支付_。


当然，毫秒单位不能以这种粒度在比特币区块链上进行结算。 通道关闭后，余额将四舍五入到最接近的聪。 但在通道的整个生命周期内，数以百万计的微支付是可能的。 闪电网络突破了小额支付障碍。(((range="endofrange", startref="ix_03_how_ln_works-asciidoc15")))

=== 比特币和闪电的共性


((("Bitcoin–Lightning Network comparisons","commonalities", id="ix_03_how_ln_works-asciidoc16", range="startofrange")))虽然闪电网络在许多方面与比特币不同，包括架构和用户体验，但它是基于比特币构建的，并保留了比特币的许多核心特性。

==== 货币单位


((("Bitcoin–Lightning Network comparisons","monetary unit commonalities")))比特币网络和闪电网络都使用相同的货币单位：比特币。闪电支付使用与比特币交易相同的比特币。 也就是说，因为货币单位是一样的，所以货币限额是一样的：小于2100万比特币。在比特币的 2100 万比特币中，一些已经分配到 2-of-2 多重签名地址，作为闪电网络支付通道的一部分。

==== 付款的不可逆性和最终性 


((("Bitcoin–Lightning Network comparisons","payment irreversibility/finality")))比特币交易和闪电支付都是不可逆转和不可改变的。任何一个系统都没有“撤消”操作或“退款”。对于任何一个付款人，您必须负责任地行事。而且，作为收款人，您可以保证交易的最终确定性。

==== 信任和交易对手风险


((("Bitcoin–Lightning Network comparisons","trust and counterparty risk")))与比特币一样，闪电网络只要求用户相信数学、加密，并且软件没有任何严重的错误。比特币和闪电网络都不需要用户信任个人、公司、机构或政府。由于闪电网络位于比特币之上并依赖比特币作为其底层基础设施，因此很明显闪电网络的安全模型降低了比特币的安全性。这意味着闪电网络在大多数情况下提供与比特币大致相同的安全性，在某些极端的情况下会略微降低安全性。

==== 无许可操作
((("Bitcoin–Lightning Network comparisons","permissionless operation")))任何可以访问互联网和软件（例如节点和钱包）的人都可以使用比特币和闪电网络。这两个网络都不需要用户获得第三方、公司、机构或政府的许可、审查或授权。政府可以在其管辖范围内取缔比特币或闪电网络，但不能阻止它们在全球范围内的使用。

==== 开源和开放系统


((("Bitcoin–Lightning Network comparisons","open source/open system")))比特币和闪电网络都是由分散在全球的志愿者社区构建的开源软件系统，在遵循其开放许可的协议下，随意使用。 两者都基于作为开放系统和开放网络运行的开放且可互操作的协议。全球、开放、免费。(((range="endofrange", startref="ix_03_how_ln_works-asciidoc16")))

=== 小结

在本章中，我们研究了闪电网络的实际工作方式以及所有组成组件。我们考察了构建、操作和关闭通道的每个步骤。 我们研究了付款是如何路由的。最后，我们将闪电网络与比特币进行了比较，分析了它们的差异和共性。(((range="endofrange", startref="ix_03_how_ln_works-asciidoc0")))

在接下来的几章中，我们将重新讨论所有这些主题，但更详细。
