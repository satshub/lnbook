[[set_up_a_lightning_node]]
== 闪电节点软件


((("Lightning node software", id="ix_04_node_client-asciidoc0", range="startofrange")))正如我们在前几章中看到的，闪电节点是参与闪电网络的计算机系统。 闪电网络不是产品或公司；它是一组定义互操作性基线的开放标准。目前，闪电节点软件已由各种公司或社区团体在构建开发。绝大多数闪电软件是_开源的_，这意味着源代码是开放。并以这样的方式获得许可，以便在开发过程中实现协作、共享和社区参与。同样，我们将在本章中介绍的已实现的闪电节点都是开源的，并且是协作开发的。


在比特币生态中，其标准由软件（比特币核心）中的 _参考实现_ 定义；在闪电网络((("BOLT (Basis of Lightning Technology) standards documents")))中，标准由一系列称为 BOLT 的标准文档定义，可在 https://github.com/lightningnetwork/lightning-rfc[_lightning-rfc_ 存储库] 中找到。


闪电网络没有标准实现，但有几个由不同团队和组织开发的相互竞争的、符合 BOLT 且可互操作的实现。这些团队在为闪电网络开发软件的同时，也为 BOLT 标准的开发和演变做出了贡献。


闪电节点软件和比特币节点软件之间还有另一个主要区别，就是闪电节点的发展，不需要基于共识规则运行，并且可以具有超出BOLT基线的扩展功能。因此，不同的团队可能会追求各种实验功能，如果这些功能成功并得到广泛部署，以后可能会成为 BOLT 的一部分。

[role="pagebreak-before"]
在本章中，您将学习如何部署设置当下使用最广、最流行的几个闪电网络节点版本。 我们按字母顺序呈现不同的节点软件，以表明我们对他们的实现没有好恶之别。 每个实现版本，都有其优点和缺点，选择哪一个将取决于多种因素。 由于它们是使用不同的编程语言（例如 Go、C 等）开发的，因此您的选择还可能取决于您对特定语言和开发工具集的熟悉程度和专业知识。

=== 闪电网络开发环境
((("development environment","Lightning node software", id="ix_04_node_client-asciidoc1", range="startofrange")))((("Lightning node software","development environment", id="ix_04_node_client-asciidoc2", range="startofrange")))如果您是开发人员，您将希望建立一个开发环境，其中包含用于编写和运行 Lightning 软件的所有工具、库和支持软件。在这个技术含量很高的章节中，我们将逐步完成该过程。如果材料变得太密集，或者您实际上并没有设置开发环境，那么请随意跳到下一章，它的技术含量较低。

==== 使用命令行
((("command line")))((("development environment","command line")))((("Lightning node software","command line")))本章中的示例，以及本书大部分内容中更广泛的示例，都是使用命令行终端进行的。 这意味着您在终端中键入命令并接收文本响应。此外，这些示例在基于 Linux 内核和 GNU 软件系统的操作系统上进行演示，特别是 Ubuntu 的最新长期稳定版本（Ubuntu 20.04 LTS）。 大多数示例可以在其他操作系统（例如 Windows 或 macOS）上复制，只需对命令进行少量修改。 操作系统之间最大的区别在于安装各种软件库及其先决条件的 _package manager_。 在给定的示例中，我们将使用 +apt+，它是 Ubuntu 的包管理器。 在 macOS 上，用于开源开发的常用包管理器是 https://brew.sh[Homebrew]，通过命令 +brew+ 访问。

在此处的大多数示例中，我们将直接从源代码构建软件。虽然这可能非常具有挑战性，但它为我们提供了最大的权力和控制权。如果遇到困难，您可以选择使用Docker容器、预编译包或其他安装机制！

[TIP]
====
在本章的许多示例中，我们将使用操作系统的命令行界面（也称为 _shell_），通过 _terminal_ 应用程序访问。 shell 将首先显示一个提示符，表明它已准备好执行您的命令。 然后你输入一个命令并按下Enter键，shell会用一些文本和一个新的提示来响应你的下一个命令。 提示在您的系统上可能看起来不同，但在以下示例中，它由 +$+ 符号表示。在示例中，当您在 +$+ 符号后看到文本时，不要键入 +$+ 符号，而是在其后立即键入命令。 然后按 Enter 键执行命令。 在示例中，每个命令后面的行是操作系统对该命令的响应。 当你看到下一个 +$+ 前缀时，你会知道它是一个新命令，你可以重复以上过程。
====


为了保持一致，我们在所有命令行示例中都使用了 +bash+ shell。 虽然其他 shell 将以类似的方式运行，并且您将能够在没有它的情况下运行所有示例，但某些 shell 脚本是专门为 +bash+ shell 编写的，可能需要进行一些更改或自定义才能在另一个 shell 中运行。 为保持一致性，您可以在 Windows 和 macOS 上安装 +bash+ shell，它默认安装在大多数 Linux 系统上。

==== 下载本书源码


((("development environment","downloading the book repository")))所有代码示例都可以在本书的线上源码库中找到。 由于源码库会保持实时最新，因此您应该始从线上源码库中查找最新版本，而不是从纸质书或电子书中复制它。


您可以通过访问 https://github.com/lnbook/lnbook[GitHub] 并点击右侧的绿色代码按钮，以 ZIP 包的形式下载源码库。


或者，您可以使用 +git+ 命令在本地计算机上，克隆下载一个源码库。 Git 是一个分布式版本控制系统，大多数开发人员使用它来协作进行软件开发并跟踪对软件源码库的更改。 按照 https://git-scm.com [来自 Git 项目] 的说明下载并安装 +git+。


要在您的计算机上创建源码库的本地副本，请运行 +git+ 命令，如下所示：

[[git-clone-lnbook]]
----
$ git clone https://github.com/lnbook/lnbook.git
----


现在，您在名为 +lnbook+ 的文件夹中拥有了图书存储库的完整副本。 您将需要通过运行以下命令，进入到新下载的目录：

[[cd-lnbook]]
----
$ cd lnbook
----


所有后续示例，都将假定您从该文件夹(./lnbook)中运行命令。

=== Docker 容器


((("Docker containers","Lightning node software and")))((("Lightning node software","Docker containers")))许多开发人员使用 _container_（一种虚拟机）来安装预配置的操作系统和所有必要依赖项的应用程序。 许多 Lightning 软件也可以使用容器系统安装，例如 https://docker.com[Docker 主页] 上的 _Docker_。 容器安装要容易得多，尤其是对于那些不习惯命令行环境的人。


本书的存储库包含一组 Docker 容器，可用于设置一致的开发环境，以便在任何系统上练习和复制示例。 因为容器是一个完整的操作系统，以一致的配置运行，所以您可以确保示例将在您的计算机上运行，而无需担心依赖关系、库版本或配置差异。

Docker 容器通常被优化为小，即占用最小的磁盘空间。 然而，在本书中，我们使用容器来统一 _标准化_ 环境并使其对所有读者都保持一致。 此外，这些容器并不打算用于在后台运行服务。 相反，它们旨在用于测试示例并通过与软件交互来学习。 由于这些原因，容器非常大，并带有许多开发工具和实用程序。 通常，由于体积减小，Alpine 发行版用于 Linux 容器。 尽管如此，我们提供基于 Ubuntu 构建的容器，因为更多的开发人员熟悉 Ubuntu，而这种熟悉程度对我们来说比大小更重要。


Docker及其命令的安装和使用详见<<appendix_docker>>。 如果您不熟悉 Docker，现在是快速回顾该部分的好时机。

您可以在本书的 _code/docker_ 文件夹下的代码目录中，找到最新的容器定义和构建配置。 每个容器都在一个单独的文件夹中，如下所示：

[[tree]]
----
$ tree -F --charset=asciii code/docker
----

[[docker-dir-list]]
----
code/docker
|-- bitcoind/
|   |-- bashrc
|   |-- bitcoind/
|   |   |-- bitcoin.conf
|   |   `-- keys/
|   |       |-- demo_address.txt
|   |       |-- demo_mnemonic.txt
|   |       `-- demo_privkey.txt
|   |-- bitcoind-entrypoint.sh
|   |-- cli
|   |-- Dockerfile
|   `-- mine.sh*
|-- c-lightning/
|   |-- bashrc
|   |-- cli
|   |-- c-lightning-entrypoint.sh
|   |-- devkeys.pem
|   |-- Dockerfile
|   |-- fund-c-lightning.sh
|   |-- lightningd/
|   |   `-- config
|   |-- logtail.sh
|   `-- wait-for-bitcoind.sh
|-- eclair/
|   |-- bashrc
|   |-- cli
|   |-- Dockerfile
|   |-- eclair/
|   |   `-- eclair.conf
|   |-- eclair-entrypoint.sh
|   |-- logtail.sh
|   `-- wait-for-bitcoind.sh
|-- lnd/
|   |-- bashrc
|   |-- cli
|   |-- Dockerfile
|   |-- fund-lnd.sh
|   |-- lnd/
|   |   `-- lnd.conf
|   |-- lnd-entrypoint.sh
|   |-- logtail.sh
|   `-- wait-for-bitcoind.sh
|-- check-versions.sh
|-- docker-compose.yml
|-- Makefile
`-- run-payment-demo.sh*
----


正如我们将在接下来的几节中看到的那样，您可以在本地构建这些容器，也可以从 https://hub.docker.com/orgs/lnbook[_Docker Hub_] 上的本书存储库中提取它们。 以下部分将假设您已安装 Docker 并熟悉 +docker+ 命令的基本用法。

=== 比特币核心和回归测试

((("Bitcoin Core", id="ix_04_node_client-asciidoc3", range="startofrange")))((("Lightning node software","Bitcoin Core and regtest", id="ix_04_node_client-asciidoc4", range="startofrange")))大多数闪电节点的实现，需要访问完整的比特币节点才能工作。


安装一个完整的比特币节点和同步比特币区块链超出了本书的范围，本身就是一项相对复杂的工作。 如果您想尝试，请参考 https://github.com/bitcoinbook/bitcoinbook[_Mastering Bitcoin_]，“第 3 章：比特币核心：参考实现”，其中讨论了比特币节点的安装和操作。


比特币节点可以在“regtest”模式下运行，节点创建一个本地模拟比特币区块链用于测试目的。 在以下示例中，我们将使用 +regtest+ 模式来演示闪电网络，而无需同步比特币节点或冒任何资金风险。


比特币核心的容器是+bitcoind+。 它被配置在 +regtest+ 模式下运行 Bitcoin Core，并每 10 秒挖掘 6 个新块。 它的远程调用 (RPC) 端口暴露在端口 18443 上，并且可以通过用户名 +regtest+ 和密码 +regtest+ 进行 RPC 调用。 您还可以使用交互式 shell 访问它并在本地运行 +bitcoin-cli+ 命令。

==== 构建比特币核心容器

((("bitcoind container", id="ix_04_node_client-asciidoc5", range="startofrange")))((("Docker containers","Bitcoin Core container", id="ix_04_node_client-asciidoc6", range="startofrange")))我们开始制作 +bitcoind+ 容器。 最简单的方法是从 _Docker Hub_ 拉取最新的容器：

[source,bash]
----
$ docker pull lnbook/bitcoind
Using default tag: latest
latest: Pulling from lnbook/bitcoind
35807b77a593: Pull complete
e1b85b9c5571: Pull complete
[...]
288f1cc78a00: Pull complete
Digest: sha256:861e7e32c9ad650aa367af40fc5acff894e89e47aff4bd400691ae18f1b550e2
Status: Downloaded newer image for lnbook/bitcoind:latest
docker.io/lnbook/bitcoind:latest

----

或者，您可以根据 _code/docker/bitcoind/Dockerfile_ 中的本地容器定义，自己构建容器。

[NOTE]
====
如果您之前使用 +pull+ 命令从 Docker Hub 拉取容器，则无需构建容器。
====

在本地构建容器将使用更少的网络带宽，但会花费更多的 CPU 时间来构建。 我们使用 +docker build+ 命令来构建它：

[source,bash]
----
$ cd code/docker
$ docker run -it --name bitcoind lnbook/bitcoind
Starting bitcoind...
Bitcoin Core starting
Waiting for bitcoind to start
bitcoind started
================================================
Imported demo private key
Bitcoin address:  2NBKgwSWY5qEmfN2Br4WtMDGuamjpuUc5q1
Private key:  cSaejkcWwU25jMweWEewRSsrVQq2FGTij1xjXv4x1XvxVRF1ZCr3
================================================
================================================
Balance: 0.00000000
================================================
Mining 101 blocks to unlock some bitcoin
[
  "34c744207fd4dd32b70bac467902bd8d030fba765c9f240a2e98f15f05338964",
  "64d82721c641c378d79b4ff2e17572c109750bea1d4eddbae0b54f51e4cdf23e",

 [...]

  "7a8c53dc9a3408c9ecf9605b253e5f8086d67bbc03ea05819b2c9584196c9294",
  "39e61e50e34a9bd1d6eab51940c39dc1ab56c30b21fc28e1a10c14a39b67a1c3",
  "4ca7fe9a55b0b767d2b7f5cf4d51a2346f035fe8c486719c60a46dcbe33de51a"
]
Mining 6 blocks every 10 seconds
Balance: 50.00000000
[
  "5ce76cc475e40515b67e3c0237d1eef597047a914ba3f59bbd62fc3691849055",
  "1ecb27a05ecfa9dfa82a7b26631e0819b2768fe5e6e56c7a2e1078b078e21e9f",
  "717ceb8b6c329d57947c950dc5668fae65bddb7fa03203984da9d2069e20525b",
  "185fc7cf3557a6ebfc4a8cdd1f94a8fa08ed0c057040cdd68bfb7aee2d5be624",
  "59001ae237a3834ebe4f6e6047dcec8fd67df0352ddc70b6b02190f982a60384",
  "754c860fe1b9e0e7292e1de96a65eaa78047feb4c72dbbde2a1d224faa1499dd"
]

----


如您所见，+bitcoind+ 启动并挖掘 101 个模拟块以启动链。 这是因为根据比特币共识规则，新开采的比特币,只有达到100个区块高度后，才可以使用。 通过挖掘 101 个区块，我们让第一个区块的 coinbase 可以使用。 在最初的挖矿活动之后，每 10 秒会挖出 6 个新区块，以保持链向前发展。

目前，区块中没有交易。 但是在我们的钱包中，已经有一些测试币被挖掘出来并且可以使用。我们会向一些闪电节点的钱包发送一些比特币，当他们连接到这条测试链时，我们就可以在闪电节点之间打开一些闪电通道。

===== 与比特币核心容器交互

同时，我们也可以通过发送 shell 命令与 +bitcoind+ 容器进行交互。 容器正在向终端发送日志文件，显示 +bitcoind+ 进程的挖矿过程。 要与 shell 交互，我们可以使用 +docker exec+ 命令在另一个终端中发出命令。 由于我们之前使用 +name+ 参数命名了正在运行的容器，因此我们可以在运行 +docker exec+ 命令时使用该名称来引用它。 首先，让我们运行一个交互式 +bash+ shell：

----
$ docker exec -it bitcoind /bin/bash
root@e027fd56e31a:/bitcoind# ps x
  PID TTY      STAT   TIME COMMAND
    1 pts/0    Ss+    0:00 /bin/bash /usr/local/bin/mine.sh
    7 ?        Ssl    0:03 bitcoind -datadir=/bitcoind -daemon
   97 pts/1    Ss     0:00 /bin/bash
  124 pts/0    S+     0:00 sleep 10
  125 pts/1    R+     0:00 ps x
root@e027fd56e31a:/bitcoind#
----



运行交互式 shell 将我们置于容器“内部”。 它以用户 +root+ 的身份登录，我们可以从新的 shell 提示符 +root@e027fd56e31a:/bitcoind#+ 中的前缀 +root@+ 中看到这一点。 如果我们发出 +ps x+ 命令来查看正在运行的进程，我们会看到 +bitcoind+ 和脚本 +mine.sh+ 都在后台运行。 要退出此 shell，请按 Ctrl-D 或键入 *+exit+*，您将返回到操作系统提示符。

除了运行交互式 shell，我们还可以发送在容器内执行的单个命令。 为方便起见，+bitcoin-cli+ 命令有一个别名“cli”，它传递了正确的配置。 因此，让我们运行它来询问有关区块链的比特币代码。 我们运行 +cli getblockchaininfo+：

[source,bash]
----
$ docker exec bitcoind cli getblockchaininfo
{
  "chain": "regtest",
  "blocks": 131,
  "headers": 131,
  "bestblockhash": "2cf57aac35365f52fa5c2e626491df634113b2f1e5197c478d57378e5a146110",

[...]

  "warnings": ""
}

----



+bitcoind+ 容器中的 +cli+ 命令允许我们向比特币核心节点发出 RPC 命令并获得 JSON 编码结果。

此外，我们所有的 Docker 容器都预装了一个名为 +jq+ 的命令行 ，用于JSON 编码器/解码器。 +jq+ 帮助我们通过命令行或内部脚本处理 JSON 格式的数据。 您可以使用 +|+ 字符将任何命令的 JSON 输出发送到 +jq+。 这个字符以及这个操作被称为“管道”。 让我们将 +pipe+ 和 +jq+ 应用于前面的命令，如下所示：

[source,bash]
----
$ docker exec bitcoind bash -c "cli getblockchaininfo | jq .blocks"
197
----


+jq .blocks+ 表示 +jq+ JSON 解码器从 [.keep-together]#+getblockchaininfo+# 结果中提取字段 +blocks+。 在我们的例子中，它提取并打印 197 的值，我们可以在后续命令中使用它。


正如您将在以下部分中看到的那样，我们可以同时运行多个容器，然后单独与它们交互。 我们可以发出命令来提取诸如闪电节点公钥之类的信息或采取诸如打开闪电通道到另一个节点之类的操作。 +docker run+ 和 +docker exec+ 命令，以及用于 JSON 解码的 +jq+，是我们构建一个混合了许多不同节点实现的工作闪电网络所需的全部内容。 这使我们能够在自己的计算机上尝试各种实验(((range="endofrange", startref="ix_04_node_client-asciidoc6")))(((range="endofrange", startref="ix_04_node_client-asciidoc5")))。(((range="endofrange", startref="ix_04_node_client-asciidoc4")))(((range="endofrange", startref="ix_04_node_client-asciidoc3")))

=== c-lightning 项目


((("c-lightning Lightning Node project", id="ix_04_node_client-asciidoc7", range="startofrange")))((("Lightning node software","c-lightning Lightning Node project", id="ix_04_node_client-asciidoc8", range="startofrange")))`c-lightning` 是 LN 协议的轻量级、高度可定制且遵循标准的实现。它是由 Blockstream 作为 Elements Project 的一部分而开发的。 该项目是开源的，在 https://github.com/ElementsProject/lightning[GitHub] 上协作开发。


在以下部分中，我们将构建一个 Docker 容器，该容器运行一个连接到我们之前构建的 +bitcoind+ 容器的“c-lightning”节点。 我们还将向您展示如何直接从源代码配置和构建“c-lightning”软件。

==== 基于Docker容器构建 c-lightning


((("c-lightning Lightning Node project","building c-lightning as Docker container")))((("Docker containers","building c-lightning as")))`c-lightning` 软件发行版有一个 Docker 容器，但它设计用于在生产系统中运行 `c-lightning` 并与 +bitcoind+ 节点一起运行。出于演示目的，我们将使用一个更简单的容器配置来运行“c-lightning”。


让我们从本书的 Docker Hub 仓库中提取“c-lightning”容器：

[source,bash]
----
$ docker pull lnbook/c-lightning
Using default tag: latest
latest: Pulling from lnbook/c-lightning

[...]

Digest: sha256:bdefcefe8a9712e7b3a236dcc5ab12d999c46fd280e209712e7cb649b8bf0688
Status: Downloaded image for lnbook/c-lightning:latest
docker.io/lnbook/c-lightning:latest

----

或者，我们可以从您之前下载到名为 +lnbook+ 的目录中的目录中构建 `c-lightning` Docker 容器。 和以前一样，我们将在 +code/docker+ 子目录中使用 +docker build+ 命令。 我们将使用 +lnbook/c-lightning+ 标签来标记容器镜像，如下所示：

[source,bash]
----
$ cd code/docker
$ docker build -t lnbook/c-lightning c-lightning
Sending build context to Docker daemon  91.14kB
Step 1/34 : ARG OS=ubuntu
Step 2/34 : ARG OS_VER=focal
Step 3/34 : FROM ${OS}:${OS_VER} as os-base
 ---> fb52e22af1b0

 [...]

Step 34/34 : CMD ["/usr/local/bin/logtail.sh"]
 ---> Running in 8d3d6c8799c5
Removing intermediate container 8d3d6c8799c5
 ---> 30b6fd5d7503
Successfully built 30b6fd5d7503
Successfully tagged lnbook/c-lightning:latest

----

我们的容器现在已经构建并可以运行了。 但是，在我们运行 `c-lightning` 容器之前，我们需要在另一个终端中启动 +bitcoind+ 容器，因为 `c-lightning` 依赖于 +bitcoind+。 我们还需要建立一个 Docker 网络，允许容器相互连接，就像驻留在同一个局域网上一样。

[TIP]
====
Docker 容器可以通过由Docker系统管理的虚拟局域网相互通信。每个容器都可以有一个自定义名称，其他容器可以使用该名称来解析其IP地址并轻松连接到它。
====

==== 启动一个Docker网络

((("c-lightning Lightning Node project","Docker network setup")))一旦建立了 Docker 网络，Docker 将在每次Docker启动时激活我们本地计算机上的网络，例如，在重新启动之后。所以我们只需要使用 +docker network create+ 命令设置一次网络即可。网络名称本身并不重要，但需要保证它在我们的计算机上必须是唯一的。 默认情况下，Docker 具有三个名为 +host+、+bridge+ 和 +none+ 的网络。 我们创建一个名为 +lnbook+ 的 新网络，操作如下：

[source,bash]
----
$ docker network create lnbook
ad75c0e4f87e5917823187febedfc0d7978235ae3e88eca63abe7e0b5ee81bfb
$ docker network ls
NETWORK ID          NAME                DRIVER              SCOPE
7f1fb63877ea        bridge              bridge              local
4e575cba0036        host                host                local
ad75c0e4f87e        lnbook              bridge              local
ee8824567c95        none                null                local
----

如您所见，运行 +docker network ls+ 命令，我们可以看到具体的 Docker 网络列表。 我们的 +lnbook+ 网络已经创建。我们可以忽略网络 ID，因为它是自动管理的。

==== 启动 bitcoind和c-lightning 容器


((("bitcoind container","and c-lightning containers")))((("c-lightning Lightning Node project","running bitcoind and c-lightning containers")))下一步是启动 +bitcoind+ 和 `c-lightning` 容器并将它们连接到 +lnbook+ 网络。 要在特定网络中运行容器，我们必须将 [.keep-together]#+network+# 参数传递给 +docker run+。 为了使容器更容易找到彼此，我们还将使用 +name+ 参数为每个容器命名。 运行 +bitcoind+ 命令如下：

[source,bash]
----
$ docker run -it --network lnbook --name bitcoind lnbook/bitcoind
----

您应该会看到 +bitcoind+ 正常启动并每隔 10 秒完成一次出块。 然后我们再打开一个新的终端窗口来启动“c-lightning”容器。我们使用带有 +network+ 和 +name+ 参数的类似 +docker run+ 命令来启动 `c-lightning`，如下所示：

[source,bash]
----
$ docker run -it --network lnbook --name c-lightning lnbook/c-lightning
Waiting for bitcoind to start...
Waiting for bitcoind to mine blocks...
Starting c-lightning...
2021-09-12T13:14:50.434Z UNUSUAL lightningd: Creating configuration directory /lightningd/regtest
Startup complete
Funding c-lightning wallet
8a37a183274c52d5a962852ba9f970229ea6246a096ff1e4602b57f7d4202b31
lightningd: Opened log file /lightningd/lightningd.log
lightningd: Creating configuration directory /lightningd/regtest
lightningd: Opened log file /lightningd/lightningd.log

----

`c-lightning` 容器启动并通过 Docker 网络连接到 +bitcoind+ 容器。 首先，我们的 `c-lightning` 节点将等待 +bitcoind+ 启动，然后等待 +bitcoind+ 将一些比特币挖到其钱包中。 最后，作为容器启动的一部分，一个脚本将向 +bitcoind+ 节点发送一个 RPC 命令，该节点创建一个交易，为“c-lightning”钱包提供 10 个测试 BTC。 现在我们的“c-lightning”节点不仅在运行，它甚至还有一些测试比特币可以玩！

正如我们用 +bitcoind+ 容器演示的那样，我们可以在另一个终端中向我们的 `c-lightning` 容器发出命令，以提取信息、打开通道等。允许我们向`c-lightning 发出命令行指令的命令 ` 节点被称为 +lightning-cli+。 这个 +lightning-cli+ 命令在这个容器中也被别名为 +cli+。 要获取 `c-lightning` 节点的信息，请在另一个终端窗口中使用以下 +docker exec+ 命令：

[source,bash]
----
$ docker exec c-lightning cli getinfo
{
   "id": "026ec53cc8940df5fed5fa18f8897719428a15d860ff4cd171fca9530879c7499e",
   "alias": "IRATEARTIST",
   "color": "026ec5",
   "num_peers": 0,
   "num_pending_channels": 0,

[...]

   "version": "0.10.1",
   "blockheight": 221,
   "network": "regtest",
   "msatoshi_fees_collected": 0,
   "fees_collected_msat": "0msat",
   "lightning-dir": "/lightningd/regtest"
}

----

现在，我们的第一个闪电节点在虚拟网络上运行起来了，并与比特币测试节点通信。 在本章后面，我们将启动更多节点并将它们相互连接以进行一些闪电支付。


在下一节中，我们还将了解如何直接从源代码下载、配置和编译 `c-lightning`。 这是一个可选的高级步骤，它将教您如何使用构建工具并允许您对 [.keep-together]#`c-lightning`# 源代码进行修改。 有了这些知识，您可以编写一些代码，修复一些错误，或者为“c-lightning”创建一个插件。

[NOTE]
====
如果您不打算深入研究 Lightning 节点的源代码或编程，您可以完全跳过下一部分。 我们上面关于Docker 容器的构建，对于本书中的大多数示例来说已经足够了。
====

==== 从源码安装 c-lightning


((("c-lightning Lightning Node project","installing c-lightning from source code")))`c-lightning` 开发人员提供了从源代码构建 `c-lightning` 的详细说明。 我们将遵循  https://github.com/ElementsProject/lightning/blob/master/doc/INSTALL.md[来自 GitHub] 的说明来构建c-lightning软件。

==== 安装依赖包

((("c-lightning Lightning Node project","installing prerequisite libraries and packages")))这些安装说明，假设您正在使用 GNU 构建工具，在 Linux 或类似系统上构建“c-lightning”。 如果不是这种情况，请在 Elements Project 仓库中查找适用于您的操作系统的安装说明。

常见的第一步是安装必备库，我们使用 +apt+ 包管理器来安装这些：

[source,bash]
----
$ sudo apt-get update

Get:1 http://security.ubuntu.com/ubuntu bionic-security InRelease [88.7 kB]
Hit:2 http://eu-north-1b.clouds.archive.ubuntu.com/ubuntu bionic InRelease
Get:3 http://eu-north-1b.clouds.archive.ubuntu.com/ubuntu bionic-updates InRelease [88.7 kB]

[...]

Fetched 18.3 MB in 8s (2,180 kB/s)
Reading package lists... Done

$ sudo apt-get install -y \
  autoconf automake build-essential git libtool libgmp-dev \
  libsqlite3-dev python python3 python3-mako net-tools zlib1g-dev \
  libsodium-dev gettext

Reading package lists... Done
Building dependency tree
Reading state information... Done
The following additional packages will be installed:
  autotools-dev binutils binutils-common binutils-x86-64-linux-gnu cpp cpp-7 dpkg-dev fakeroot g++ g++-7 gcc gcc-7 gcc-7-base libalgorithm-diff-perl

 [...]

Setting up libsigsegv2:amd64 (2.12-2) ...
Setting up libltdl-dev:amd64 (2.4.6-14) ...
Setting up python2 (2.7.17-2ubuntu4) ...
Setting up libsodium-dev:amd64 (1.0.18-1) ...

[...]
$
----

经过几分钟的大量滚屏输出后，您将安装所有必要的依赖包和库。其中许多库也被其他 Lightning 包使用，并且通常是软件开发所需要的。

==== 获取 c-lightning 源码


((("c-lightning Lightning Node project","copying the latest version of c-lightning source code")))接下来，我们将从源码库中clone最新版本的“c-lightning”。 为此，我们将使用 +git clone+ 命令，它将一个受版本控制的副本克隆到您的本地计算机上，从而使您可以使其与后续更改保持同步，而无需再次下载整个存储库：

[source,bash]
----
$ git clone --recurse https://github.com/ElementsProject/lightning.git
Cloning into 'lightning'...
remote: Enumerating objects: 24, done.
remote: Counting objects: 100% (24/24), done.
remote: Compressing objects: 100% (22/22), done.
remote: Total 53192 (delta 5), reused 5 (delta 2), pack-reused 53168
Receiving objects: 100% (53192/53192), 29.59 MiB | 19.30 MiB/s, done.
Resolving deltas: 100% (39834/39834), done.

$ cd lightning

----

现在，我们将 `c-lightning` 的副本克隆到了 _lightning_ 子文件夹中，然后我们使用了 +cd+（更改目录）命令进入了子文件夹。

==== 编译 c-lightning 源码


((("c-lightning Lightning Node project","compiling the c-lightning source code")))接下来，我们使用许多开源项目中常见的一组 _build scripts_。 这些构建脚本使用 +configure+ 和 +make+ 命令，允许我们：

* 选择构建选项并检查必要的依赖项（+configure+）
* 构建和安装可执行文件和库 (+make+)


对 configure 使用 +help 选项， 运行结果将向我们展示所有可用选项：

----
$ ./configure --help
Usage: ./configure [--reconfigure] [setting=value] [options]

Options include:
  --prefix= (default /usr/local)
    Prefix for make install
  --enable/disable-developer (default disable)
    Developer mode, good for testing
  --enable/disable-experimental-features (default disable)
    Enable experimental features
  --enable/disable-compat (default enable)
    Compatibility mode, good to disable to see if your software breaks
  --enable/disable-valgrind (default (autodetect))
    Run tests with Valgrind
  --enable/disable-static (default disable)
    Static link sqlite3, gmp and zlib libraries
  --enable/disable-address-sanitizer (default disable)
    Compile with address-sanitizer
----

我们不需要更改此示例的任何默认值。 因此我们可以直接运行 [.keep-together]#+configure+#，如下：

----
$ ./configure

Compiling ccan/tools/configurator/configurator...done
checking for python3-mako... found
Making autoconf users comfortable... yes
checking for off_t is 32 bits... no
checking for __alignof__ support... yes

[...]

Setting COMPAT... 1
PYTEST not found
Setting STATIC... 0
Setting ASAN... 0
Setting TEST_NETWORK... regtest
$
----

接下来，我们使用 +make+ 命令构建 `c-lightning` 项目的库、组件和可执行文件。 这部分需要几分钟才能完成，并且消耗大量的计算机 CPU 和磁盘。运行 +make+：

[source,bash]
----
$ make

cc -DBINTOPKGLIBEXECDIR="\"../libexec/c-lightning\"" -Wall -Wundef -Wmis...

[...]

cc   -Og  ccan-asort.o ccan-autodata.o ccan-bitmap.o ccan-bitops.o ccan-...

----

如果一切顺利，您将不会看到任何 +ERROR+ 消息。如果出现 +ERROR+，上面的执行将自动终止。 `c-lightning` 软件包已从源代码编译完成，现在我们准备安装我们在上一步中编译生成的可执行组件：
----
$ sudo make install

mkdir -p /usr/local/bin
mkdir -p /usr/local/libexec/c-lightning
mkdir -p /usr/local/libexec/c-lightning/plugins
mkdir -p /usr/local/share/man/man1
mkdir -p /usr/local/share/man/man5
mkdir -p /usr/local/share/man/man7
mkdir -p /usr/local/share/man/man8
mkdir -p /usr/local/share/doc/c-lightning
install cli/lightning-cli lightningd/lightningd /usr/local/bin
[...]
----

为了验证 +lightningd+ 和 +lightning-cli+ 命令已正确安装，我们将查询每个可执行文件的版本信息试试，如下：

[source,bash]
----
$ lightningd --version
v0.10.1-34-gfe86c11
$ lightning-cli --version
v0.10.1-34-gfe86c11
----


该版本包括：

- 最新的发布版本 (v0.10.1)
- 然后是自发布以来的更改数量 (34)
- 最后是一个哈希，用于准确识别哪个修订版 (fe86c11)

您可能会看到与之前显示的版本不同的版本，因为该软件在本书出版很久之后仍在继续发展。 但是，无论您看到什么版本，命令执行并响应版本信息这一事实意味着您已经成功构建了 `c-lightning` 软件。

=== LND 闪电网络项目

((("Lightning Network Daemon (LND) node project", id="ix_04_node_client-asciidoc9", range="startofrange")))((("Lightning node software","Lightning Network Daemon node project", id="ix_04_node_client-asciidoc10", range="startofrange")))LND是闪电实验室的 LN 节点的完整实现。 LND 项目提供了许多可执行应用程序，包括 +lnd+（守护程序本身）和 +lncli+（命令行实用程序）。 LND 有几个可插拔的后端链服务，包括 btcd（一个完整的节点）、+bitcoind+（比特币核心）和 Neutrino（一个新的、实验性的轻客户端）。 LND 是用 Go 编程语言编写的。 该项目是开源的，在 https://github.com/LightningNetwork/lnd[GitHub] 上协同开发。


在接下来的几节中，我们将构建一个 Docker 容器来运行 LND，从源代码构建 LND，并学习如何配置和运行 LND。

==== LND Docker容器

((("Lightning Network Daemon (LND) node project","LND Docker container")))我们可以从本书的 Docker Hub 仓库中提取 LND 示例 Docker 容器：

[source,bash]
----
$ docker pull lnbook/lnd
Using default tag: latest
latest: Pulling from lnbook/lnd
35807b77a593: Already exists
e1b85b9c5571: Already exists
52f9c252546e: Pull complete

[...]

Digest: sha256:e490a0de5d41b781c0a7f9f548c99e67f9d728f72e50cd4632722b3ed3d85952
Status: Downloaded newer image for lnbook/lnd:latest
docker.io/lnbook/lnd:latest

----

或者，我们可以在本地构建 LND 容器。 容器文件位于_code/docker/lnd_。 我们将工作目录更改为 _code/docker_ 并执行 +docker build+ 命令：

[source,bash]
----
$ cd code/docker
$ docker build -t lnbook/lnd lnd
Sending build context to Docker daemon  9.728kB
Step 1/29 : FROM golang:1.13 as lnd-base
 ---> e9bdcb0f0af9
Step 2/29 : ENV GOPATH /go

[...]

Step 29/29 : CMD ["/usr/local/bin/logtail.sh"]
 ---> Using cache
 ---> 397ce833ce14
Successfully built 397ce833ce14
Successfully tagged lnbook/lnd:latest

----

我们的容器现在可以运行了。 与我们之前构建的“c-lightning”容器一样，LND 容器也依赖于一个正在运行的 Bitcoin Core 实例。 和以前一样，我们需要在另一个终端中启动 +bitcoind+ 容器，并通过 Docker 网络将 LND 连接到它。 我们已经建立了一个名为 +lnbook+ 的 Docker 网络，在这里我们将再次使用它。


[TIP]
====
通常，每个节点运营商在自己的服务器上运行自己的闪电节点和自己的比特币节点。 对我们来说，一个 +bitcoind+ 容器可以服务于许多闪电节点。 在我们的模拟网络上，我们可以运行多个闪电节点，所有节点都以 +regtest+ 模式连接到一个比特币节点。
====

==== 运行bitcoind和LND容器

((("bitcoind container","and LND containers")))((("Lightning Network Daemon (LND) node project","running bitcoind and LND containers")))和之前一样，我们在一个终端启动 +bitcoind+ 容器，在另一个终端启动 LND。 如果您已经运行了 +bitcoind+ 容器，则无需重新启动它。要在 +lnbook+ 网络中启动 +bitcoind+，我们使用 +docker run+，如下所示：

[source,bash]
----
$ docker run -it --network lnbook --name bitcoind lnbook/bitcoind
----

接下来，我们启动刚刚构建的 LND 容器。 如前所述，我们需要将它附着到 +lnbook+ 网络并为其命名：

[source,bash]
----
$ docker run -it --network lnbook --name lnd lnbook/lnd
Waiting for bitcoind to start...
Waiting for bitcoind to mine blocks...
Starting lnd...
Startup complete
Funding lnd wallet
{"result":"dbd1c8e2b224e0a511c11efb985dabd84d72d935957ac30935ec4211d28beacb","error":null,"id":"lnd-run-container"}
[INF] LTND: Version: 0.13.1-beta commit=v0.13.1-beta, build=production, logging=default, debuglevel=info
[INF] LTND: Active chain: Bitcoin (network=regtest)
[INF] RPCS: Generating TLS certificates...

----

LND 容器启动并通过 Docker 网络连接到 +bitcoind+ 容器。 首先，我们的 LND 节点将等待 +bitcoind+ 启动，然后等待 +bitcoind+ 将一些比特币挖到其钱包中。 最后，作为容器启动的一部分，脚本将向 +bitcoind+ 节点发送 RPC 命令，从而创建为 LND 钱包提供 10 个测试 BTC 的交易。

正如我们之前演示的，我们可以在另一个终端中向容器发送命令，例如提取信息、打开通道等。允许我们向 +lnd+ 守护进程发出命令行指令的命令称为 +lncli+。 类似的，在这个容器中，我们提供了运行 +lncli+ 的别名 +cli+ 以及所有适当的参数。 让我们在另一个终端窗口中使用 +docker exec+ 命令获取节点信息：

[source,bash]
----
$ docker exec lnd cli getinfo
{
    "version": "0.13.1-beta commit=v0.13.1-beta",
    "commit_hash": "596fd90ef310cd7abbf2251edaae9ba4d5f8a689",
    "identity_pubkey": "02d4545dccbeda29a10f44e891858940f4f3374b75c0f85dcb7775bb922fdeaa14",

[...]

}
----

到目前，我们有另一个闪电节点(LND)在 +lnbook+ 网络上运行并与 +bitcoind+ 通信。 如果您仍在运行 `c-lightning` 容器，那么现在有两个节点正在运行。 它们尚未相互连接，但我们将很快将它们相互连接。

[source,bash]
----
$ docker run -it --network lnbook --name lnd2 lnbook/lnd
----

在上述命令中，我们启动了另一个 LND 容器，将其命名为 +lnd2+。 名称完全取决于您，只要它们是唯一的。 如果不提供名称，Docker 会通过随机组合“naughty_einstein”等两个英文单词来构造一个唯一的名称。

在下一节中，我们将了解如何直接从源代码下载和编译 LND。 这是一个可选的高级步骤，它将教您如何使用 Go 语言构建工具并允许您对 LND 源代码进行修改。 有了这些知识，您可以编写一些代码或修复一些错误。

[NOTE]
====
如果您不打算深入研究 Lightning 节点的源代码或编程，您可以完全跳过下一部分。 我们刚刚构建的 Docker 容器对于本书中的大多数示例来说已经足够了。
====

==== 从源码安装 LND
((("Lightning Network Daemon (LND) node project","installing LND from source code")))在本节中，我们将从头开始构建 LND。 LND 是用 Go 编程语言编写的。 如果您想了解有关 Go 的更多信息，请搜索 +golang+ 而不是 +go+ 以避免不相关的结果。 因为它是用 Go 而不是 C 或 C++ 编写的，所以它使用的“构建”框架与我们之前在 `c-lightning` 中看到的 GNU autotools/make 框架不同。 不过不要担心，安装和使用 golang 工具非常容易，我们将在这里展示每个步骤。 Go 是一种出色的协作软件开发语言，因为无论作者数量如何，它都能生成非常一致、精确且易于阅读的代码。 Go 以一种专注和“极简主义”风格，来保持语言版本之间的一致性。 作为一种编译语言，它也相当高效。


我们将按照 https://github.com/lightningnetwork/lnd/blob/master/docs/INSTALL.md[LND 项目文档] 中的安装说明进行操作。

首先，我们将安装 +golang+ 包和相关的库。 我们严格要求 Go 版本为 1.13 或更高版本。 官方 Go 语言安装包以二进制文件形式，从 https://golang.org/dl[the Go Project] 分发。 为方便起见，它们也被打包为 Debian 软件包，可通过 +apt+ 命令获得。 您可以按照说明 https://golang.org/dl[来自 Go 项目]  或在 Debian/Ubuntu Linux 系统上使用以下 +apt+ 命令，如 https://github.com/golang/go/wiki中所述/Ubuntu[GitHub 上 Go 语言的 wiki 页面]：

[source,bash]
----
$ sudo apt install golang-go
----

通过运行以下命令检查您是否安装了正确的版本并可以使用：

[source,bash]
----
$ go version
go version go1.13.4 linux/amd64
----

我们有 1.13.4版本的Go，所以我们准备好了……开始吧！ 接下来，我们需要告诉任何程序在哪里可以找到 Go 代码。 这是通过设置环境变量 +GOPATH+ 来完成的。 通常 Go 代码位于用户主目录中名为 _gocode_ 的目录中。 通过以下两个命令，我们设置 +GOPATH+ 的值， 并确保您的 shell 将 GOPATH 添加到  +PATH+ 中。 请注意，用户的主目录在 shell 中称为 ~。

[source,bash]
----
$ export GOPATH=~/gocode
$ export PATH=$PATH:$GOPATH/bin
----

为了避免每次打开 shell 时都必须设置这些环境变量，可以用您的编辑器将上面两行添加到主目录中的 +bash+ shell 配置文件 _.bashrc_ 的末尾。

==== 下载 LND 源码

((("Lightning Network Daemon (LND) node project","copying LND source code")))
与当今许多开源项目一样，LND 的源代码位于 GitHub (_www.github.com_) 上。 +go get+ 命令可以使用 Git 协议直接获取它：

[source,bash]
----
$ go get -d github.com/lightningnetwork/lnd
----

+go get+ 完成后，您将在 +GOPATH+ 下拥有一个包含 LND 源代码的子目录。

==== 编译LND源代码

((("Lightning Network Daemon (LND) node project","compiling LND source code")))LND 使用 +make+ 构建系统。要构建项目，我们先进到 LND 的源代码目录，然后像如下这样使用 +make+：

[source,bash]
----
$ cd $GOPATH/src/github.com/lightningnetwork/lnd
$ make && make install
----

几分钟后，您将安装两个新命令： +lnd+ 和 +lncli+。 试用它们并检查它们的版本以确保它们已安装：

[source,bash]
----
$ lnd --version
lnd version 0.10.99-beta commit=clock/v1.0.0-106-gc1ef5bb908606343d2636c8cd345169e064bdc91
$ lncli --version
lncli version 0.10.99-beta commit=clock/v1.0.0-106-gc1ef5bb908606343d2636c8cd345169e064bdc91
----

您可能会看到与之前显示的版本不同的版本，因为该软件在本书出版很久之后仍在继续发展。 但是，无论您看到什么版本，命令执行并显示版本信息这一事实意味着您已经成功构建了 LND 软件。(((range="endofrange", startref="ix_04_node_client-asciidoc8")))(((range="endofrange", startref="ix_04_node_client-asciidoc7")))

=== Eclair 闪电项目
((("Eclair Lightning node project", id="ix_04_node_client-asciidoc11", range="startofrange")))((("Lightning node software","Eclair Lightning node project", id="ix_04_node_client-asciidoc12", range="startofrange")))Eclair（闪电的法语）是由 ACINQ 制作开发的闪电网络的 Scala 实现。 Eclair 也是最受欢迎和开创性的移动闪电钱包之一，我们曾在<<getting-started>>中演示过闪电支付。 在本节中，我们将安装运行 Lightning 节点的 Eclair 版本。 Eclair 是一个开源项目，可以在 https://github.com/ACINQ/eclair[GitHub] 上找到。

在接下来的几节中，我们将构建一个 Docker 容器来运行 Eclair，就像我们之前使用 `c-lightning` 和 LND 所做的那样。 我们还将直接从源代码构建 Eclair。

==== Eclair Docker容器

((("Eclair Lightning node project","Docker container for")))我们可以从 Docker Hub 仓库中拉取本书的 Eclair 容器：

[source,bash]
----
$ docker pull lnbook/eclair
Using default tag: latest
latest: Pulling from lnbook/eclair
35807b77a593: Already exists
e1b85b9c5571: Already exists

[...]

c7d5d5c616c2: Pull complete
Digest: sha256:17a3d52bce11a62381727e919771a2d5a51da9f91ce2689c7ecfb03a6f028315
Status: Downloaded newer image for lnbook/eclair:latest
docker.io/lnbook/eclair:latest

----

或者，我们可以在本地构建容器。 至此，您几乎是 Docker 基本操作方面的专家了！ 在本节中，我们将重复许多以前看到的命令来构建 Eclair 容器。 容器位于 _code/docker/eclair_ 中。 我们从一个终端开始，将工作目录切换到 _code/docker_ 并发出 +docker build+ 命令：

[source,bash]
----
$ cd code/docker
$ docker build -t lnbook/eclair eclair
Sending build context to Docker daemon  11.26kB
Step 1/27 : ARG OS=ubuntu
Step 2/27 : ARG OS_VER=focal
Step 3/27 : FROM ${OS}:${OS_VER} as os-base
 ---> fb52e22af1b0

[...]

Step 27/27 : CMD ["/usr/local/bin/logtail.sh"]
 ---> Running in fe639120b726
Removing intermediate container fe639120b726
 ---> e6c8fe92a87c
Successfully built e6c8fe92a87c
Successfully tagged lnbook/eclair:latest

----

我们的镜像现在可以运行了。 Eclair 容器还依赖于一个正在运行的 Bitcoin Core 实例。 和以前一样，我们需要在另一个终端中启动 +bitcoind+ 容器，并通过 Docker 网络将 Eclair 连接到它。 我们之前已经建立了一个名为 +lnbook+ 的 Docker 网络，在这里我们将重用它。

Eclair 和 LND 或“c-lightning”之间的一个显着区别是 Eclair 不包含单独的比特币钱包，而是直接依赖于比特币核心中的比特币钱包。 回想一下使用 LND的时候，我们通过执行交易将比特币从 Bitcoin Core 的钱包转移到 LND 的比特币钱包来为其比特币钱包提供资金。使用 Eclair 不需要此步骤。 在运行 Eclair 时，直接使用 Bitcoin Core 钱包作为资金来源来开通通道。 因此，与 LND 或“c-lightning”容器不同，Eclair 容器不包含在启动时将比特币转入其钱包的脚本。

==== 运行bitcoind和Eclair容器

((("bitcoind container","and Eclair containers", id="ix_04_node_client-asciidoc13", range="startofrange")))((("Eclair Lightning node project","running bitcoind and Eclair containers", id="ix_04_node_client-asciidoc14", range="startofrange")))和以前一样，我们在一个终端启动 +bitcoind+ 容器，在另一个终端启动 Eclair 容器。 如果您已经运行了 +bitcoind+ 容器，则无需重新启动它。 要在 +lnbook+ 网络中启动 +bitcoind+，我们可以使用 +docker run+ 命令，如下所示：

[source,bash]
----
$ docker run -it --network lnbook --name bitcoind lnbook/bitcoind
----

接下来，我们启动我们刚刚构建的 Eclair 容器。 我们需要将它附加到 +lnbook+ 网络并为其命名，就像我们对其他容器所做的那样：

[source,bash]
----
$ docker run -it --network lnbook --name eclair lnbook/eclair
Waiting for bitcoind to start...
Waiting for bitcoind to mine blocks...
Starting eclair...
Eclair node started
INFO  o.b.Secp256k1Context - secp256k1 library successfully loaded
INFO  fr.acinq.eclair.Plugin - loading 0 plugins
INFO  a.e.slf4j.Slf4jLogger - Slf4jLogger started
INFO  fr.acinq.eclair.Setup - hello!
INFO  fr.acinq.eclair.Setup - version=0.4.2 commit=52444b0

[...]

----

Eclair 容器启动并通过 Docker 网络连接到 +bitcoind+ 容器。首先，我们的 Eclair 节点将等待 +bitcoind+ 启动，然后等待 +bitcoind+ 将一些比特币开采到其钱包中。

正如我们之前演示的，我们可以在另一个终端中向我们的容器发送命令，例如：提取信息、打开通道等。允许我们向 +eclair+ 守护进程发送指令的命令称为 +eclair-cli+。 和以前一样，在这个容器中，我们为 +eclair-cli+ 提供了一个有用的别名，简称为 +cli+，它包含了必要的参数。 在另一个终端窗口中使用 +docker exec+ 命令从 Eclair 获取节点信息：

[source,bash]
----
$ docker exec eclair cli getinfo
{
  "version": "0.4.2-52444b0",
  "nodeId": "02fa6d5042eb8098e4d9c9d99feb7ebc9e257401ca7de829b4ce757311e0301de7",
  "alias": "eclair",
  "color": "#49daaa",
  "features": {

[...]

  },
  "chainHash": "06226e46111a0b59caaf126043eb5bbf28c34f3a5e332a1fc7b2b73cf188910f",
  "network": "regtest",
  "blockHeight": 779,
  "publicAddresses": [],
  "instanceId": "01eb7a68-5db0-461b-bdd0-29010df40d73"
}

----

我们现在有另一个闪电节点在 +lnbook+ 网络上运行并与 +bitcoind+ 通信。 您可以在同一闪电网络上运行任意数量和任意组合的闪电节点。任意数量的 Eclair、LND 和“c-lightning”节点可以共存。例如，要运行第二个 Eclair 节点，您可以使用不同的容器名称发送 +docker run+ 命令，如下所示：

[source,bash]
----
$ docker run -it --network lnbook --name eclair2 lnbook/eclair
----

在上面的命令中，我们启动了另一个名为 +eclair2+ 的 Eclair 容器。

在下一节中，我们还将了解如何直接从源代码下载和编译 Eclair。 这是一个可选的高级步骤，它将教您如何使用 Scala 和 Java 语言构建工具，并允许您对 Eclair 的源代码进行修改。 有了这些知识，您就可以编写一些代码或修复一些错误。

[NOTE]
====
如果您不打算深入研究 Lightning 节点的源代码或编程，您可以完全跳过下一部分。 我们刚刚构建的 Docker 容器对于本书中的大多数示例来说已经足够了。(((range="endofrange", startref="ix_04_node_client-asciidoc14")))(((range="endofrange", startref="ix_04_node_client-asciidoc13")))
====

==== 从源码安装 Eclair

((("Eclair Lightning node project","installing Eclair from source code")))在本节中，我们将从头开始构建 Eclair。 Eclair 是用 Scala 编程语言编写的，使用 Java 编译器编译。 要运行 Eclair，我们首先需要安装 Java 及其构建工具。 我们将按照 Eclair 项目的 https://github.com/ACINQ/eclair/blob/master/BUILD.md[_BUILD.md_ 文档] 中的说明进行操作。


所需的 Java 编译器是 OpenJDK 11 的一部分。我们还需要一个名为 Maven 的构建框架，版本为 3.6.0 或更高版本。

在 Debian/Ubuntu Linux 系统上，我们可以使用 +apt+ 命令同时安装 OpenJDK 11 和 Maven，如下所示：

[source,bash]
----
$ sudo apt install openjdk-11-jdk maven
----

通过运行以下命令验证您是否安装了正确的版本：

[source,bash]
----
$ javac -version
javac 11.0.7
$ mvn -v
Apache Maven 3.6.1
Maven home: /usr/share/maven
Java version: 11.0.7, vendor: Ubuntu, runtime: /usr/lib/jvm/java-11-openjdk-amd64

----

我们已安装了 OpenJDK 11.0.7 和 Maven 3.6.1，这够用了。

==== Copying the Eclair Source Code

((("Eclair Lightning node project","copying Eclair source code")))Eclair 的源代码在 GitHub 上。 +git clone+ 命令可以为我们创建一个本地副本。 让我们切换到主目录并在那里运行它：

[source,bash]
----
$ cd ~
$ git clone https://github.com/ACINQ/eclair.git

----

+git clone+ 完成后，您将拥有一个子目录 +eclair+，其中包含 Eclair 的源代码。

==== 编译 Eclair 源码

((("Eclair Lightning node project","compiling Eclair source code")))Eclair 使用 +Maven+ 构建系统。为了构建项目，我们进入 Eclair 源码目录，然后使用  +mvn package+  命令，如下所示：

[source,bash]
----
$ cd eclair
$ mvn package
[INFO] Scanning for projects...
[INFO] ------------------------------------------------------------------------
[INFO] Reactor Build Order:
[INFO]
[INFO] --------------------< fr.acinq.eclair:eclair_2.13 >---------------------
[INFO] Building eclair_2.13 0.4.3-SNAPSHOT                                [1/4]
[INFO] --------------------------------[ pom ]---------------------------------

[...]


[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time:  01:06 min
[INFO] Finished at: 2020-12-12T09:43:21-04:00
[INFO] ------------------------------------------------------------------------

----

几分钟后，Eclair 包的构建就完成。 但是，“package”操作也将运行测试用例，其中一些连接到 Internet 的命令，可能会失败。 如果要跳过测试，请在命令中添加 +-DskipTests+ 。

现在，按照来自 GitHub 的 https://github.com/ACINQ/eclair#installing-eclair[安装 Eclair 的说明]，解压缩并运行构建包。

恭喜！ 您已经从源代码构建了Eclair，后面可以编写代码、测试、修复错误并为这个项目做出贡献！

=== 构建完整的多样化闪电节点网络

((("Lightning Network (example)","building a complete network of diverse Lightning nodes", id="ix_04_node_client-asciidoc15", range="startofrange")))((("Lightning node software","building a complete network of diverse Lightning nodes", id="ix_04_node_client-asciidoc16", range="startofrange")))本节介绍的最后一个示例将汇集我们上面构建的各种容器，以形成由各种（LND、`c-lightning`、Eclair）节点实现组成的闪电网络。我们通过将节点连接在一起并打开从一个节点到另一个节点的通道来组成网络。最后一步，我们将通过这些渠道进行付款！

在此示例中，我们将构建一个由四个闪电节点组成的演示闪电网络，分别名为 Alice、Bob、Chan 和 Dina。 我们将 Alice 连接到 Bob，Bob 连接到 Chan，Chan 连接到 Dina。 这显示在<<alice_bob_chan_dina_network_demo>>.

[[alice_bob_chan_dina_network_demo]]
.A small demonstration network of four nodes
image::images/mtln_1002.png["A small demonstration network of four nodes"]

最后，我们将让 Dina 创建一张发票并让 Alice 支付该发票。由于 Alice 和 Dina 没有直接连接，因此支票将以 HTLC的形式， 路由到所有支付通道。

==== 使用 docker-compose 来编排 Docker 容器

((("docker-compose","orchestrating Docker containers with")))((("Lightning Network (example)","using docker-compose to orchestrate Docker containers")))为了演示这个示例，我们将使用一个 _容器构建_ 工具，该工具是一个名为 +docker-compose+ 的命令。 该命令允许我们指定一个由多个容器组成的应用程序，并通过一起启动所有协作容器来运行该应用程序。

首先，让我们安装+docker-compose+。 https://docs.docker.com/compose/install[instructions] 取决于您的操作系统。

完成安装后，您可以通过运行 docker-compose 来验证您的安装，如下所示：

[source,bash]
----
$ docker-compose version
docker-compose version 1.21.0, build unknown
[...]

----

我们将使用的最常见的 +docker-compose 命令是 +up+ 和 +down+，例如 +docker-compose up+ 。

==== docker-compose 配置

((("docker-compose","configuration")))((("Lightning Network (example)","docker-compose configuration")))+docker-compose+ 的配置文件位于 _code/docker_ 目录中，命名为 _docker-compose.yml_。 它包含一个网络规范和四类容器中的每一个。顶部看起来像这样：

----
version: "3.3"
networks:
  lnnet:

services:
  bitcoind:
    container_name: bitcoind
    build:
        context: bitcoind
    image: lnbook/bitcoind:latest
    networks:
      - lnnet
    expose:
      - "18443"
      - "12005"
      - "12006"

  Alice:
    container_name: Alice
----

前面的部分定义了一个名为 +lnnet+ 的网络和一个名为 +bitcoind+ 的容器，bitcoind容器将连接到 +lnnet+ 网络。 容器与我们在本章开头构建的容器相同。 我们公开了容器的三个端口，允许我们向它发送命令并监控块和交易。 接下来，配置指定一个名为“Alice”的 LND 容器。 再往下，您还会看到名为“Bob”（`c-lightning`）、“Chan”（Eclair）和“Dina”（又是 LND）的容器的规范。

由于这些不同的实现都遵循闪电技术基础 (BOLT) 规范，并且已经针对互操作性进行了广泛的测试，因此它们共同构建闪电网络没有任何问题。

==== 启动闪电网络示例

((("Lightning Network (example)","starting the network")))在开始之前，应该确保我们还没有运行任何容器。 如果一个新容器与已经运行的容器同名，那么它将无法启动。 根据需要使用 +docker ps+、+docker stop+ 和 +docker rm+ 来停止和删除任何当前正在运行的容器！

[TIP]
====
因为我们对这些编排的 Docker 容器使用相同的名称，所以我们可能需要“清理”以避免任何名称冲突。
====

[role="pagebreak-before"]
为了开始这个例子，我们切换到包含 _docker-compose.yml_ 配置文件的目录，执行命令 +docker-compose up+：

[source,bash]
----
$ cd code/docker
$ docker-compose up
Creating Chan     ... done
Creating Dina     ... done
Creating bitcoind ... done
Creating Bob      ... done
Creating Alice    ... done
Attaching to Chan, Dina, Alice, bitcoind, Bob
Alice       | Waiting for bitcoind to start...
Bob         | Waiting for bitcoind to start...
Dina        | Waiting for bitcoind to start...
Chan        | Waiting for bitcoind to start...
bitcoind    | Starting bitcoind...
bitcoind    | Waiting for bitcoind to start
bitcoind    | bitcoind started
bitcoind    | ================================================

[...]

Chan        | Starting eclair...
Dina        | Starting lnd...
Chan        | Eclair node started
Alice       | ...Waiting for bitcoind to mine blocks...
Bob         | ...Waiting for bitcoind to mine blocks...
Alice       | Starting lnd...
Bob         | Starting c-lightning...

[...]

----

启动后，因为每个节点启动并报告其进度，您将看到整个日志文件流。 它在您的屏幕上可能看起来很混乱，但每个输出行都以容器名称为前缀，前缀名如前所述。 如果您只想查看来自某一个容器的日志，您可以在另一个终端窗口中使用带有 +f+ (_follow_) 标志和特定容器名称的 +docker-compose logs+ 命令：

[source,bash]
----
$ docker-compose logs -f Alice
----

==== 开通道和路由支付
((("Lightning Network (example)","opening channels and routing a payment", id="ix_04_node_client-asciidoc17", range="startofrange")))((("payment channel","opening in Lightning Network", id="ix_04_node_client-asciidoc18", range="startofrange")))((("routing","Lightning Network example", id="ix_04_node_client-asciidoc19", range="startofrange")))我们的闪电网络现在应该正在运行。 正如我们在本章前面部分中看到的，我们可以使用 +docker exec+ 命令向正在运行的 Docker 容器发出命令。 无论我们是使用 +docker run+ 启动容器还是使用 +docker-compose up+ 启动一堆容器，我们仍然可以使用 Docker 命令单独访问容器。

付款演示包含在名为 +run-payment-demo.sh+ 的 Bash shell 脚本中。 要运行此演示，您必须在计算机上安装 Bash shell。 大多数 Linux 和类 Unix 系统（例如 macOS）都预装了 +bash+。 Windows 用户可以安装适用于 Linux 的 Windows 子系统，并使用像 Ubuntu 这样的 Linux 发行版在他们的计算机上获取本机 +bash+ 命令。

让我们运行脚本看看它的效果，然后我们再看看它内部是如何工作的。 我们使用 +bash+ 命令运行它：

----
$ cd code/docker
$ bash run-payment-demo.sh
Starting Payment Demo
======================================================

Waiting for nodes to startup
- Waiting for bitcoind startup...
- Waiting for bitcoind mining...
- Waiting for Alice startup...
- Waiting for Bob startup...
- Waiting for Chan startup...
- Waiting for Dina startup...
All nodes have started
======================================================

Getting node IDs
- Alice:  0335e200756e156f1e13c3b901e5ed5a28b01a3131cd0656a27ac5cc20d4e71129
- Bob:    033e9cb673b641d2541aaaa821c3f9214e8a11ada57451ed5a0eab2a4afbce7daa
- Chan:   02f2f12182f56c9f86b9aa7d08df89b79782210f0928cb361de5138364695c7426
- Dina: 02d9354cec0458e0d6dee5cfa56b83040baddb4ff88ab64960e0244cc618b99bc3
======================================================

[...]

Setting up connections and channels
- Alice to Bob
- Open connection from Alice node to Bob's node

- Create payment channel Alice->Bob


[...]

Get 10k sats invoice from Dina
- Dina invoice:
lnbcrt100u1psnuzzrpp5rz5dg4wy27973yr7ehwns5ldeusceqdaq0hguu8c29n4nsqkznjsdqqcqzpgxqyz5vqsp5vdpehw33fljnmmexa6ljk55544f3syd8nfttqlm3ljewu4r0q20q9qyyssqxh5nhkpjgfm47yxn4p9ecvndz7zddlsgpufnpyjl0kmnq227tdujlm0acdv39hcuqp2vhs40aav70c9yp0tee6tgzk8ut79mr877q0cpkjcfvr
======================================================

Attempting payment from Alice to Dina
Successful payment!

----



从输出中可以看出，脚本首先获取四个节点中每个节点的节点 ID（公钥）。 然后，它连接节点并建立一个从每个节点到网络中下一个节点的 1,000,000 satoshi 通道。 最后，它从 Dina 的节点开具 10,000 satoshis 的发票，并从 Alice 的节点支付发票。

[TIP]
====
如果脚本失败，您可以尝试从头开始再次运行它。 或者您可以手动的逐条运行脚本中的命令并查看结果。
====

该脚本中有很多内容需要反复学习。随着您对底层技术的了解，越来越多的内容将变得清晰。 建议您稍后重新温习这个示例。

当然，除了三通道、四节点的支付之外，您还可以使用这个测试网络做更多的事情。 以下提供一些建议性的实验想法：

* 通过启动更多不同类型的节点来创建更复杂的网络。 编辑 _docker-compose.yml_ 文件并复制部分，根据需要重命名容器。

* 将节点连接成更复杂的拓扑：圆形路由、中心辐射型或全网状。

* 创造大量支付请求，以耗尽渠道容量。 然后以相反的方向运行支付以重新平衡渠道。 看看路由算法如何适应。

* 更改通道费用以查看路由算法如何协商多个路由以及它应用了哪些优化。 便宜的长途路线比昂贵的短路线好吗？

* 尝试从节点到自身的循环支付，以重新平衡自己的渠道。看看这如何影响其他通道和节点。

* 在一个循环中生成数百或数千张小发票，然后在另一个循环中尽快支付。 测量这个测试网络每秒可以支撑多少笔交易。

=== 总结

在本章中，我们研究了实现 BOLT 规范的各种项目。 我们构建了容器来运行示例闪电网络，并学习了如何从源代码构建每个项目。 您现在已准备好进一步探索和深入挖掘。(((range="endofrange", startref="ix_04_node_client-asciidoc0")))